'CR3000 Series Datalogger

'Copyright (c) 2002, 2006, 2010 Campbell Scientific, Inc. All rights reserved.

'14 Jun 17
'version 3.3
'pn 18443


'The following sensors are measured:
'
Const SENSOR_CSAT3        = TRUE   'CSAT3                     three dimensional sonic anemometer (overrides the sonic in an IRGASON or EC150)
Const SENSOR_CSAT3B       = FALSE  'CSAT3B                    three dimensional sonic anemometer (overrides the sonic in an IRGASON or EC150)
Const SENSOR_IRGASON      = FALSE  'IRGASON or EC150 (CSAT3A) open path infrared gas analyzer (CO2 and H2O) and three dimensional sonic anemometer head
Const SENSOR_KH20         = FALSE  'KH20                      krypton hygrometer (H2O)
Const SENSOR_FW           = FALSE  'FW05                      finewire thermocouple probe
Const SENSOR_LI7500       = TRUE   'LI-7500(A)                open path infrared gas analyzer (CO2 and H2O)
Const SENSOR_TMPR_RH      = FALSE  'HC2S3/HMP155A/HMP45C      temperature and relative humidity probe

Const SENSOR_Q7_1         = FALSE  'Q7.1                      net radiometer
Const SENSOR_NR_LITE_2    = FALSE  'NR Lite 2                 net radiometer
Const SENSOR_CNR_2        = FALSE  'CNR 2                     net radiometer
Const SENSOR_NR_01_CNR_1  = FALSE  'NR 01/CNR 1               net radiometer
Const SENSOR_CNR_4        = TRUE   'CNR 4                     net radiometer
Const SENSOR_LI200X       = FALSE  'LI-200X                   silicon pyranometer
Const SENSOR_CS300        = FALSE  'CS300                     silicon pyranometer
Const SENSOR_LI190SB      = FALSE  'LI-190SB                  quantum sensor
Const SENSOR_TCAV         = TRUE   'TCAV                      type E thermocouple averaging soil temperature probes
Const SENSOR_CS616        = FALSE  'CS616                     water content reflectometers (volumetric soil moisture)
Const SENSOR_CS65X        = TRUE   'CS650 or CS655            water content reflectometers (volumetric soil moisture)
Const SENSOR_HFT3         = FALSE  'HFT3                      soil heat flux plates
Const SENSOR_HFP01        = TRUE   'HFP01                     soil heat flux plates
Const SENSOR_HFP01SC      = FALSE  'HFP01SC                   soil heat flux plates
Const SENSOR_SI_111       = FALSE  'SI-111                    infrared surface temperature
Const SENSOR_TE525        = FALSE  'TE525                     tipping bucket rain gauge

Const FIND_DIAG_BITS      = TRUE   'Set to TRUE to find individual diagnostic bits.


' The sign convention for the fluxes is positive away from the surface and
'negative towards the surface.
'
' Before computing online fluxes, the datalogger will introduce lags into the
'eddy covariance data to account for the fixed instrument delays. The lags are
'dependent on the instrument setting and/or the scan interval. Search for "Fixed
'inherent lag" and set the delay to the appropriate value. The raw data is not
'lagged.
'
' The site attendant must load in several constants and calibration values.
'Search for the text string "unique" to find the locations where unique
'constants and calibration values are entered.


'*** Unit Definitions ***

'Symbol   Units
'C        Celsius
'degrees  degrees (angle)
'g        grams
'J        Joules
'kg       kilograms
'kPa      kilopascals
'm        meters
'mg       milligrams
'mmol     millimoles
'mol      moles
's        seconds
'umol     micromols
'uSeconds microseconds
'V        volts
'W        Watts


'*** Station constants.
'Start of Constants Customization Section
Const SCAN_INTERVAL = 100  'Unique value, measurement rate 100 ms (10 Hz) or 50 ms (20 Hz).
Const OUTPUT_INTERVAL = 30 'Unique value, online flux data output interval in minutes.
Const NUM_DAY_CRD = 356    'Unique value, number of days of flux data to store on a 16 GB CF card (44 days = 2 GB). This value will vary with configuration.
Const SDM_PER = 30         'Unique value, default SDM clock speed.
#If ( (SENSOR_TMPR_RH = FALSE) AND (SENSOR_IRGASON = FALSE ) AND (SENSOR_LI7500 = FALSE) ) Then
Const SITE_RHO_A = 1.1     'Unique value for site air density (kg/m^3).
Const SITE_PRESS = 100     'Unique value for site pressure (kPa).
Const SITE_CP = 1004.67    'Estimate of specific heat capacity [J/(kg K)].
#EndIf
#If ( (SENSOR_TMPR_RH = TRUE) AND (SENSOR_IRGASON = FALSE ) AND (SENSOR_LI7500 = FALSE) ) Then
Const SITE_PRESS = 100     'Unique value for site pressure (kPa).
#EndIf
#If ( SENSOR_CSAT3 = TRUE ) Then


Const CSAT3_SDM_ADDR = 3             'Unique SDM address for CSAT3.
'*** Beginning of CSAT3 wiring ***
'SDM-C1  SDM Data (green)
'SDM-C2  SDM Clock (white)
'SDM-C3  SDM Enable (brown)
'G       SDM reference (black)
'        SDM shield (clear)

'+12V    power (red)
'G       power reference (black)
'        power shield (clear)
'*** End of CSAT3 wiring ***
#EndIf
#If ( SENSOR_CSAT3B = TRUE ) Then


Const CSAT3B_SDM_ADDR = 3            'Unique SDM address for CSAT3B.
'*** Beginning of CSAT3B wiring ***
'SDM-C1  SDM Data (green)
'SDM-C2  SDM Clock (white)
'SDM-C3  SDM Enable (brown)
'G       SDM reference (black)
'        SDM shield (clear)

'+12V    power (red)
'G       power reference (black)
'        power shield (clear)
'*** End of CSAT3B wiring ***
#EndIf
#If ( SENSOR_IRGASON = TRUE ) Then


Const EC100_SDM_ADDR = 1             'Unique SDM address for EC100.
Const CO2_SIG_STRGTH_THRESHOLD = 0.7 'Unique value - filter gas analyzer CO2 data when CO2 signal strength is less than CO2_SIG_STRGTH.
Const H2O_SIG_STRGTH_THRESHOLD = 0.7 'Unique value - filter gas analyzer H2O data when H2O signal strength is less than H2O_SIG_STRGTH.
'*** Beginning of EC150 w/ or w/o CSAT3A sonic head wiring ***
'SDM-C1  SDM Data (green)
'SDM-C2  SDM Clock (white)
'SDM-C3  SDM Enable (brown)
'G       SDM reference (black)
'        SDM shield (clear)

'+12V    power (red)
'G       power reference (black)
'        power shield (clear)
'*** End of EC150 w/ or w/o CSAT3A sonic head wiring ***
#EndIf
#If ( SENSOR_LI7500 = TRUE ) Then


Const LI7500_SDM_ADDR = 7            'Unique SDM address for LI-7500(A).
Const AGC_THRESHOLD = 99             'Unique value - filter LI-7500(A) data with AGC greater than AGC_THRESHOLD.
'*** Beginning of LI-7500(A) wiring ***
'SDM-C1  SDM Data (gray/blue)
'SDM-C2  SDM Clock (blue/white)
'SDM-C3  Enable (brown/brown)
'G       SDM reference (black/black)
'        SDM shield (white/bare)

'+12V    power (red with white/red)
'G       power reference (red with black/black)
'        ground (green/not used)
'*** End of LI-7500(A) wiring ***
#EndIf
#If ( SENSOR_KH20 = TRUE ) Then


Const KH_ANALOG_INPUT = 1            'Unique differential analog input channel KH20.
Const XKW = -0.150                   'Unique path length times absorption coefficient for water vapor [m^3 / g].
Const X = 1                          'Unique path length of the KH20 [cm].
Const KW = -0.150                    'Unique absorption coefficient for water vapor [m^3 / (g cm)].
'*** Beginning of KH20 wiring ***
'1H      Signal (white)
'1L      Signal reference (black)
'gnd     Shield (clear)

'12V     Power (red)
'G       Power reference (black)
'        Power shield (clear)
'*** End of KH20 wiring ***
#EndIf
#If ( SENSOR_FW = TRUE ) Then


Const FW_ANALOG_INPUT = 5            'Unique differential analog input channel for FW05.
'*** Beginning of FW05 wiring ***
'5H      Signal (purple)
'5L      Signal reference (red)
'gnd     Shield
'*** End of FW05 wiring ***
#EndIf
#If ( SENSOR_TMPR_RH = TRUE ) Then


Const TMPR_RH_ANALOG_INPUT = 19      'Unique single-ended input channel for temperature and humidity probe.
Const TMPR_RH_T_MULT = 0.1           'Unique multiplier for temperature; HC2S3 = 0.1, HMP155A = 0.14, or HMP45C = 0.1.
Const TMPR_RH_T_OFFSET = -40         'Unique offset for temperature; HC2S3 = -40, HMP155A = -80, or HMP45C = -40.
'*** Beginning of HC2S3 or HMP wiring ***
'10H     Temperature signal (brown/yellow)
'10L     Relative humidity signal (white/blue)
'gnd     Signal reference (yellow/white)
'        Shield (clear/clear)

'12V     Power (green/red)
'G       Power reference (gray/black)
'*** End of HC2S3 or HMP wiring ***
#EndIf
#If ( SENSOR_Q7_1 = TRUE ) Then


Const NR_ANALOG_INPUT = 2            'Unique differential analog input channel.
Const Q7_1_POS_CAL = 10              'Unique positive multiplier for Q7.1.
Const Q7_1_NEG_CAL = 10              'Unique negative multiplier for Q7.1.
'*** Beginning of Q7.1 wiring ***
'2H      Signal (red)
'2L      Signal reference (black)
'gnd     Shield (clear)
'*** End of Q7.1 wiring ***
#EndIf
#If ( SENSOR_NR_LITE_2 = TRUE ) Then


Const NR_ANALOG_INPUT = 2            'Unique differential analog input channel.
Const NRLITE_CAL = 1000/16           'Unique multiplier for NR Lite 2 (1000/sensitivity).
'*** Beginning of NR Lite 2 wiring ***
'2H      Signal (white/red)
'2L      Signal reference (green/blue)
'gnd     short jumper wire to 2L
'        Shield (clear)
'*** End of NR Lite 2 wiring ***
#EndIf
#If ( SENSOR_CNR_2 = TRUE ) Then


Const NR_ANALOG_INPUT = 1            'Unique differential analog input channel.
Const NR_SW_CAL = 1000/22            'Unique multiplier for CNR 2 net shortwave radiation (1000/sensitivity).
Const NR_LW_CAL = 1000/12            'Unique multiplier for CNR 2 net longwave radiation (1000/sensitivity).
'*** Beginning of CNR 2 wiring ***
'1H      Net shortwave radiation signal (white)
'1L      Net shortwave radiation signal reference (blue)
'gnd     Shield (clear)

'2H      Net longwave radiation signal (brown)
'2L      Net longwave radiation signal reference (black)
'gnd
'*** End of CNR 2 wiring ***
#EndIf
#If ( SENSOR_NR_01_CNR_1 = TRUE ) Then


Const T_NR_ANALOG_INPUT = 1          'Unique differential analog input channel.
Const T_NR_CURRENT_EXCITATION = Ix1  'Unique current excitation channel.
Const NR_ANALOG_INPUT = 2            'Unique differential analog input channel.
Const NR_SW_INCOMING_CAL = 1000/15   'Unique multiplier for NR 01/CNR 1 shortwave incoming radiation (1000/sensitivity).
Const NR_SW_OUTGOING_CAL = 1000/15   'Unique multiplier for NR 01/CNR 1 shortwave outgoing radiation (1000/sensitivity).
Const NR_LW_INCOMING_CAL = 1000/8    'Unique multiplier for NR 01/CNR 1 longwave incoming radiation (1000/sensitivity).
Const NR_LW_OUTGOING_CAL = 1000/8    'Unique multiplier for NR 01/CNR 1 longwave outgoing radiation (1000/sensitivity).
'*** Beginning of NR 01/CNR 1 wiring ***
'1H      Pt100 signal (white/yellow)
'1L      Pt100 signal reference (green/green)
'gnd     Pt100 shield (silver/bare)

'IX1     Pt100 current excitation (red/red)
'IXR     Pt100 current excitation reference (blue/blue)

'2H      Incoming shortwave radiation signal (red/red)
'2L      Incoming shortwave radiation signal reference (blue/blue)
'gnd     Shield (clear/clear)

'3H      Outgoing shortwave radiation signal (white/white)
'3L      Outgoing shortwave radiation signal reference (green/black)

'4H      Incoming longwave radiation signal (brown/gray or orange)
'4L      Incoming longwave radiation signal reference (yellow/yellow)

'5H      Outgoing longwave radiation signal (purple or pink/brown)
'5L      Outgoing longwave radiation signal reference (gray/green)
'*** End of NR 01/CNR 1 wiring ***
#EndIf
#If ( SENSOR_CNR_4 = TRUE ) Then


Const T_NR_ANALOG_INPUT = 1          'Unique single-ended analog input channel.
Const T_NR_VOLTAGE_EXCITATION = Vx1  'Unique voltage excitation channel.
Const NR_ANALOG_INPUT = 2            'Unique differential analog input channel.
Const NR_SW_INCOMING_CAL = 1000/15   'Unique multiplier for CNR 4 shortwave incoming radiation (1000/sensitivity).
Const NR_SW_OUTGOING_CAL = 1000/15   'Unique multiplier for CNR 4 shortwave outgoing radiation (1000/sensitivity).
Const NR_LW_INCOMING_CAL = 1000/8    'Unique multiplier for CNR 4 longwave incoming radiation (1000/sensitivity).
Const NR_LW_OUTGOING_CAL = 1000/8    'Unique multiplier for CNR 4 longwave outgoing radiation (1000/sensitivity).
'*** Beginning of CNR 4 wiring ***
'1H      Thermistor signal (white)
'gnd     Thermistor signal reference (black)
'        Shield (clear)

'Vx1     Thermistor excitation (red)

'2H      Incoming shortwave radiation signal (red)
'2L      Incoming shortwave radiation signal reference (blue)
'gnd     Shield (clear)
'        short jumper wire to 2L

'3H      Outgoing shortwave radiation signal (white)
'3L      Outgoing shortwave radiation signal reference (black)
'gnd     short jumper wire to 3L

'4H      Incoming longwave radiation signal (gray)
'4L      Incoming longwave radiation signal reference (yellow)
'gnd     short jumper wire to 4L

'5H      Outgoing longwave radiation signal (brown)
'5L      Outgoing longwave radiation signal reference (green)
'gnd     short jumper wire to 5L
'*** End of CNR 4 wiring ***
#EndIf
#If ( SENSOR_LI200X = TRUE ) Then


Const LI_200X_ANALOG_INPUT = 14      'Unique differential analog input channel.
Const LI_200X_CAL = 200              'Unique multiplier for LI-200X.
'*** Beginning of LI-200X wiring ***
'14H     Signal (red)
'14L     Signal reference (black)
'gnd     Signal ground (white)
'        Shield (clear)
'*** End of LI-200X wiring ***
#EndIf
#If ( SENSOR_CS300 = TRUE ) Then


Const CS300_ANALOG_INPUT = 14        'Unique differential analog input channel.
Const CS300_CAL = 5                  'Unique multiplier for CS300.
'*** Beginning of CS300 wiring ***
'14H     Signal (red)
'14L     Signal reference (black)
'gnd     jumper to 13L
'        Shield (clear)
'*** End of CS300 wiring ***
#EndIf
#If ( SENSOR_LI190SB = TRUE ) Then


Const LI_190SB_ANALOG_INPUT = 13     'Unique differential analog input channel.
Const LI_190SB_CAL = 1000/0.604/5.00 'Unique multiplier for LI-190SB (1000/0.604/sensitivity).
'*** Beginning of LI-190SB wiring ***
'13H     Signal (red)
'13L     Signal reference (black)
'gnd     jumper to 13L
'        Shield (clear)
'*** End of LI-190SB wiring ***
#EndIf
#If ( SENSOR_CS616 = TRUE ) Then


Const CS616_ANALOG_INPUT = 9         'Unique single-ended analog input channel.
Const CS616_POWER_CTRL = 4           'Unique control port.
Const NMBR_CS616 = 2                 'Unique number of CS616 to measure.
'*** Beginning of CS616 wiring ***
'5H      Signal #1 (green)
'5L      Signal #2 (green)
'C4      Power control #1 (orange)
'        Power control #2 (orange)
'G       Shield #1 (clear)
'        Shield #2 (clear)

'12V     Power #1 (red)
'        Power #2 (red)
'G       Signal reference #1 (black)
'        Signal reference #2 (black)
'*** End of CS616 wiring ***
#EndIf
#If ( SENSOR_CS65X = TRUE ) Then


Const CS65X_1_SDI12_PORT = 5         'Unique control port.
Const CS65X_2_SDI12_PORT = 7         'Unique control port.
'Search for text "Duplicate above for additional probes." to add code for additional probes.
Const NMBR_CS65X = 2                 'Unique number of CS65X to measure.
'*** Beginning of CS65X wiring ***
'C5      SDI-12 data #1 (SDI-12 address = 0) (green)
'C7      SDI-12 data #2 (SDI-12 address = 0) (green)
'G       RS-232 Rx #1 (orange)
'        RS-232 Rx #2 (orange)

'12V     SDI-12 power #1 (red)
'        SDI-12 power #2 (red)
'G       SDI-12 data/power reference #1 (black)
'        Shield #1 (clear)
'        SDI-12 data/power reference #2 (black)
'        Shield #2 (clear)
'*** End of CS65X wiring ***
#EndIf
#If ( SENSOR_TCAV = TRUE ) Then


Const TCAV_ANALOG_INPUT = 11         'Unique differential analog input channel.
Const NMBR_TCAV = 2                  'Unique number of TCAV to measure.
'*** Beginning of TCAV wiring ***
'11H     Signal #1 (purple)
'11L     Signal reference #1 (red)
'gnd     Shield #1 (clear)

'12H     Signal #2 (purple)
'12L     Signal reference #2 (red)
'gnd     Shield #2 (clear)
'*** End of TCAV wiring ***
#EndIf
#If ( SENSOR_HFT3 = TRUE ) Then


Const SHF_ANALOG_INPUT = 6           'Unique differential analog input channel.
Const NMBR_SHF = 4                   'Unique number of HFT3 to measure.
Data 42                              'Unique multiplier for HFT3 #1.
Data 42                              'Unique multiplier for HFT3 #2.
Data 42                              'Unique multiplier for HFT3 #3.
Data 42                              'Unique multiplier for HFT3 #4.
'*** Beginning of HFT3 wiring ***
'6H      Signal #1 (black)
'6L      Signal reference #1 (white)
'gnd     Shield #1 (clear)

'7H      Signal #2 (black)
'7L      Signal reference #2 (white)
'gnd     Shield #2 (clear)

'8H      Signal #3 (black)
'8L      Signal reference #3 (white)
'gnd     Shield #3 (clear)

'9H      Signal #4 (black)
'9L      Signal reference #4 (white)
'gnd     Shield #4 (clear)
'*** End of HFT3 wiring ***
#EndIf
#If ( SENSOR_HFP01 = TRUE ) Then


Const SHF_ANALOG_INPUT = 6           'Unique differential analog input channel.
Const NMBR_SHF = 2                   'Unique number of HFP01 to measure.
Data 1000/62                         'Unique multiplier for HFP01 #1 (1000/sensitivity).
Data 1000/62                         'Unique multiplier for HFP01 #2 (1000/sensitivity).
'*** Beginning of HFP01 wiring ***
'6H      Signal #1 (white)
'6L      Signal reference #1 (green)
'gnd     Shield #1 (clear)

'7H      Signal #2 (white)
'7L      Signal reference #2 (green)
'gnd     Shield #2 (clear)
'*** End of HFP01 wiring ***
#EndIf
#If ( SENSOR_HFP01SC = TRUE ) Then


Const SHF_ANALOG_INPUT = 11          'Unique single-ended analog input channel.
Const NMBR_SHF = 4                   'Unique number of HFP01SC to measure.
Data 1000/62                         'Unique multiplier for HFP01SC #1 (1000/sensitivity).
Data 1000/62                         'Unique multiplier for HFP01SC #2 (1000/sensitivity).
Data 1000/62                         'Unique multiplier for HFP01SC #3 (1000/sensitivity).
Data 1000/62                         'Unique multiplier for HFP01SC #4 (1000/sensitivity).
'*** Beginning of HFP01SC wiring ***
'6H      Signal #1 (white)
'6L      Heater resistor signal #1 (yellow)
'gnd     Signal reference #1 (green)
'        Shield #1 (clear)
'        Heater resistor signal reference #1 (purple)
'        Heater shield #1 (clear)

'7H      Signal #2 (white)
'7L      Heater resistor signal #2 (yellow)
'gnd     Signal reference #2 (green)
'        Shield #2 (clear)
'        Heater resistor signal reference #2 (purple)
'        Heater shield #2 (clear)

'8H      Signal #3 (white)
'8L      Heater resistor signal #3 (yellow)
'gnd     Signal reference #3 (green)
'        Shield #3 (clear)
'        Heater resistor signal reference #3 (purple)
'        Heater shield #3 (clear)

'9H      Signal #4 (white)
'9L      Heater resistor signal #4 (yellow)
'gnd     Signal reference #4 (green)
'        Shield #4 (clear)
'        Heater resistor signal reference #4 (purple)
'        Heater shield #4 (clear)

'SW12-1  Heater power #1 (red)
'        Heater power #2 (red)
'        Heater power #3 (red)
'        Heater power #4 (red)
'G       Heater reference #1 (black)
'        Heater reference #2 (black)
'        Heater reference #3 (black)
'        Heater reference #4 (black)
'*** End of HFP01SC wiring ***
#EndIf
#If ( SENSOR_SI_111 = TRUE ) Then


Const IR_TARGET_ANALOG_INPUT = 3     'Unique differential analog input channel for SI-111 target temperature.
Const IR_BODY_ANALOG_INPUT = 7       'Unique single-ended analog input channel for SI-111 body temperature.
Const IR_VOLTAGE_EXCITATION = Vx2    'Unique voltage excitation channel.
Const MC0 = 1419700000               'Unique mC0 constant for SI-111.
Const MC1 = 7841000                  'Unique mC1 constant for SI-111.
Const MC2 = 82213                    'Unique mC2 constant for SI-111.
Const BC0 = -17215000                'Unique bC0 constant for SI-111.
Const BC1 = 185020                   'Unique bC1 constant for SI-111.
Const BC2 = 13114                    'Unique bC2 constant for SI-111.

'*** Beginning of SI-111 wiring ***
'3H      Target signal (red)
'3L      Target signal reference (black)
'gnd     Target shield (clear)

'2L      Body temperature signal (green)
'gnd     Body temperature signal reference (blue)
'        Body temperature shield (clear)

'VX2     Body temperature excitation (white)
'*** End of SI-111 wiring ***
#EndIf
#If ( SENSOR_TE525 = TRUE ) Then


Const PRECIP_PULSE_INPUT = 1         'Unique pulse input channel for TE525.
Const PRECIP_CAL = 0.1               'Unique multiplier for TE525.
'*** Beginning of TE525 wiring ***
'P1      Signal (black)
'G       Signal reference (white)
'        Shield (clear)
'*** End of TE525 wiring ***
#EndIf
'End of Constants Customization Section


'POWER IN
'12V     datalogger (red)
'G       datalogger (black)


'EXTERNAL POWER SUPPLY
'+12V    datalogger (red)
'G       datalogger (black)


#If (SENSOR_TMPR_RH = TRUE) OR _
    (SENSOR_Q7_1 = TRUE) OR _
    (SENSOR_NR_LITE_2 = TRUE) OR _
    (SENSOR_CNR_2 = TRUE) OR _
    (SENSOR_NR_01_CNR_1 = TRUE ) OR _
    (SENSOR_CNR_4 = TRUE) OR _
    (SENSOR_LI200X = TRUE) OR _
    (SENSOR_CS300 = TRUE) OR _
    (SENSOR_LI190SB = TRUE) OR _
    (SENSOR_TCAV = TRUE) OR _
    (SENSOR_HFT3 = TRUE) OR _
    (SENSOR_HFP01 = TRUE) OR _
    (SENSOR_HFP01SC = TRUE) OR _
    (SENSOR_SI_111 = TRUE) Then
Const ANALOG_INTEGRATION = _60Hz       'Slow sequence analog measurement integration time, _60Hz or _50Hz.
#EndIf


PipeLineMode

'*** General constants and variables ***
Const OFFSET = 17                                        'An offset delay that will be introduced to the eddy covariance data used to compute online fluxes.
Const SCAN_BUFFER_SIZE = 60*INT (1000/SCAN_INTERVAL)     'Compute a 60 second scan buffer.

Const NUM_DAY_CPU = 1                                              'Number of days of flux data to store on the CPU.
Const FLUX_SIZE_CPU = Ceiling ((NUM_DAY_CPU*1440)/OUTPUT_INTERVAL) 'Size of flux data table on CPU [days].
Const FLUX_SIZE_CRD = Ceiling ((NUM_DAY_CRD*1440)/OUTPUT_INTERVAL) 'Size of flux data table on CRD [days].

Const MU_WPL = 28.97/18.02                               'Ratio of the molecular weight of dry air to that of water vapor.
Const R = 8.3143e-3                                      'Universal gas constant [kPa m^3/(K mol)].
Const RD = R/28.97                                       'Gas constant for dry air [kPa m^3/(K g)].
Const RV = R/18.02                                       'Gas constant for water vapor [kPa m^3/(K g)].
Dim Lv                                                   'Latent heat of vaporization [J/g].
Dim Cp                                                   'Specific heat capacity [J/(kg K)].

Dim dly_data_out(7)                                      'Array used to temporarily store the lagged record.

'Other measurements.
Public panel_tmpr
Public batt_volt
Units panel_tmpr = C
Units batt_volt = V
#If ( SENSOR_IRGASON = TRUE ) Then

'System power control variables.
Const SYSTEM_PWR_OFF_SET_PT = 10
Const SYSTEM_PWR_DEAD_BAND_WIDTH = 2

#EndIf
'Program working variables.
Dim scan_count As Long                                   'Number scans executed.
Dim slowsequence_finished_f As Boolean                   'Flag used to indicate the SlowSequence has finished its scan.
Dim slowsequence_disable_f As Boolean = TRUE             'Flag used to decimate statistics in main scan.
Dim sys_conf_var_file As Long                            'Filehandle for the file that contains the system configuration variables in the CPU.
Dim sys_conf_var_file_size As Long                       'Size of the system configuration file stored on the CPU.
Dim sys_conf_var(2) = {0,0}                              'Variable saved are:  sonic_azimuth and irga_off_flg
Dim process_time
Dim buff_depth
Dim i As Long                                            'Main scan index variable.
#If ( (SENSOR_CS616) OR (SENSOR_HFP01SC = TRUE) ) Then
Dim ii As Long                                           'Slow sequence scan index variable.
#EndIf
Dim n = 1
Dim err_message_str As String * 76
Dim value_str(2) As String * 20
Alias value_str(1) = curr_value_str
Alias value_str(2) = prev_value_str
Units process_time = us
Units buff_depth = scans
Units n = samples
#If ( SENSOR_CSAT3 = TRUE ) Then


'*** Beginning of CSAT3(A) constants, variables, and working data table ***
Const CSAT_OPT = INT (1000/SCAN_INTERVAL)  'Compute CSAT3 Execution Parameter.
Const DELAY_CSAT3 = 2                      'Fixed CSAT3 delay.
Const CSAT3_REC_BCK = OFFSET-DELAY_CSAT3-1 'Number of records back to align CSAT3 data. Minus one scan because the SDM instruction is at the end of the program.

Public sonic_azimuth                       'Enter sonic azimuth using keyboard after program has compiled (azimuth of the CSAT3(A) negative x-axis see Section 3.2.1 CSAT3A Azimuth in the OPEC manual).
Units sonic_azimuth = degrees

Public sonic(5)
Alias sonic(1) = Ux
Alias sonic(2) = Uy
Alias sonic(3) = Uz
Alias sonic(4) = Ts
Alias sonic(5) = diag_sonic
Public diag_sonic_aggregate As Long
Units Ux = m/s
Units Uy = m/s
Units Uz = m/s
Units Ts = C
Units diag_sonic = arb
Units diag_sonic_aggregate = arb

Dim diag_bits_sonic(4) As Long             'Sonic warning flags.
Alias diag_bits_sonic(1) = sonic_amp_l_f   'Amplitude low warning flag.
Alias diag_bits_sonic(2) = sonic_amp_h_f   'Amplitude high warning flag.
Alias diag_bits_sonic(3) = sonic_sig_lck_f 'Poor signal lock warning flag.
Alias diag_bits_sonic(4) = sonic_del_T_f   'Delta temperature warning flag.
Units diag_bits_sonic = arb
Dim diag_sonic_tmp As Long                 'Temporary variable used to break out the CSAT3(A) diagnostic bits.

Dim sonic_irga_raw(12)                     'CSAT3 and EC150 (not lagged).

Dim sonic_disable_f As Boolean             'TRUE when CSAT3(A) diagnostic warning flags are on or CSAT3(A) has not sent data or an SDM signature error is reported.
Dim Ts_absolute                            'Sonic temperature (K).
Dim sonic_azimuth_prev

Dim cov_array_sonic(1,4)                   'Arrays used to hold the input data for the covariance instructions (CSAT3(A)).
Dim cov_out_sonic(18)                      'CSAT3(A) statistics.
Alias cov_out_sonic(1) = Hs                'Sensible heat flux using sonic temperature.
Alias cov_out_sonic(2) = tau               'Momentum flux.
Alias cov_out_sonic(3) = u_star            'Friction velocity.
Alias cov_out_sonic(4) = Ts_stdev
Alias cov_out_sonic(5) = Ts_Ux_cov
Alias cov_out_sonic(6) = Ts_Uy_cov
Alias cov_out_sonic(7) = Ts_Uz_cov
Alias cov_out_sonic(8) = Ux_stdev
Alias cov_out_sonic(9) = Ux_Uy_cov
Alias cov_out_sonic(10) = Ux_Uz_cov
Alias cov_out_sonic(11) = Uy_stdev
Alias cov_out_sonic(12) = Uy_Uz_cov
Alias cov_out_sonic(13) = Uz_stdev
Alias cov_out_sonic(14) = wnd_spd
Alias cov_out_sonic(15) = rslt_wnd_spd
Alias cov_out_sonic(16) = wnd_dir_sonic
Alias cov_out_sonic(17) = std_wnd_dir
Alias cov_out_sonic(18) = wnd_dir_compass
Units Hs = W/m^2
Units tau = kg/(m s^2)
Units u_star = m/s
Units Ts_stdev = C
Units Ts_Ux_cov = C m/s
Units Ts_Uy_cov = C m/s
Units Ts_Uz_cov = C m/s
Units Ux_stdev = m/s
Units Ux_Uy_cov = (m/s)^2
Units Ux_Uz_cov = (m/s)^2
Units Uy_stdev = m/s
Units Uy_Uz_cov = (m/s)^2
Units Uz_stdev = m/s
Units wnd_spd = m/s
Units rslt_wnd_spd = m/s
Units wnd_dir_sonic = degrees
Units std_wnd_dir = degrees
Units wnd_dir_compass = degrees

DataTable (delay_3d,TRUE,OFFSET)
  TableHide
  Sample (5,sonic_irga_raw(1),IEEE4)
EndTable

DataTable (comp_cov_3d,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  'Compute covariances from CSAT3(A) data.
  Covariance (4,cov_array_sonic(1,1),IEEE4,sonic_disable_f,10)
  WindVector (1,Uy,Ux,IEEE4,sonic_disable_f,0,1,2)
EndTable
#If (SENSOR_IRGASON = FALSE) Then

DisplayMenu ("System Control",TRUE)
  MenuItem ("Sonic Azmth",sonic_azimuth)
EndMenu
#EndIf
'*** End of CSAT3(A) constants, variables, and working data table ***
#EndIf
#If ( SENSOR_CSAT3B = TRUE ) Then


'*** Beginning of CSAT3B constants, variables, and working data table ***
Const DELAY_CSAT3 = 0                      'Fixed CSAT3B delay.
Const CSAT3_REC_BCK = OFFSET-DELAY_CSAT3-1 'Number of records back to align CSAT3B data. Minus one scan because the SDM instruction is at the end of the program.

Public sonic_azimuth                       'Enter sonic azimuth using keyboard after program has compiled (azimuth of the CSAT3B negative x-axis).
Units sonic_azimuth = degrees

Public sonic(5)
Alias sonic(1) = Ux
Alias sonic(2) = Uy
Alias sonic(3) = Uz
Alias sonic(4) = Ts
Alias sonic(5) = diag_sonic
Public diag_sonic_aggregate As Long
Units Ux = m/s
Units Uy = m/s
Units Uz = m/s
Units Ts = C
Units diag_sonic = arb
Units diag_sonic_aggregate = arb

Dim diag_bits_sonic(9) As Long                  'Sonic warning flags.
Alias diag_bits_sonic(1) = sonic_amp_l_f        'Amplitude low warning flag.
Alias diag_bits_sonic(2) = sonic_amp_h_f        'Amplitude high warning flag.
Alias diag_bits_sonic(3) = sonic_sig_lck_f      'Poor signal lock warning flag.
Alias diag_bits_sonic(4) = sonic_del_T_f        'Delta temperature warning flag.
Alias diag_bits_sonic(5) = sonic_aq_sig_f       'Sonic acquiring signals warning flag.
Alias diag_bits_sonic(6) = sonic_low_volt_f     'Sonic voltage low warning flag.
Alias diag_bits_sonic(7) = sonic_trig_f         'Datalogger trigger error flag.
Alias diag_bits_sonic(8) = sonic_intrnl_hmdty_f 'Internal humidity warning flag.
Alias diag_bits_sonic(9) = sonic_cal_err_f      'Signature error in reading CSAT3A sonic head calibration data.

Units diag_bits_sonic = arb
Dim diag_sonic_tmp As Long                 'Temporary variable used to break out the CSAT3B diagnostic bits.

Dim sonic_irga_raw(12)                     'CSAT3B and EC150 (not lagged).

Dim sonic_disable_f As Boolean             'TRUE when CSAT3B diagnostic warning flags are on or CSAT3B has not sent data or an SDM signature error is reported.
Dim Ts_absolute                            'Sonic temperature (K).
Dim sonic_azimuth_prev

Dim cov_array_sonic(1,4)                   'Arrays used to hold the input data for the covariance instructions (CSAT3B).
Dim cov_out_sonic(18)                      'CSAT3B statistics.
Alias cov_out_sonic(1) = Hs                'Sensible heat flux using sonic temperature.
Alias cov_out_sonic(2) = tau               'Momentum flux.
Alias cov_out_sonic(3) = u_star            'Friction velocity.
Alias cov_out_sonic(4) = Ts_stdev
Alias cov_out_sonic(5) = Ts_Ux_cov
Alias cov_out_sonic(6) = Ts_Uy_cov
Alias cov_out_sonic(7) = Ts_Uz_cov
Alias cov_out_sonic(8) = Ux_stdev
Alias cov_out_sonic(9) = Ux_Uy_cov
Alias cov_out_sonic(10) = Ux_Uz_cov
Alias cov_out_sonic(11) = Uy_stdev
Alias cov_out_sonic(12) = Uy_Uz_cov
Alias cov_out_sonic(13) = Uz_stdev
Alias cov_out_sonic(14) = wnd_spd
Alias cov_out_sonic(15) = rslt_wnd_spd
Alias cov_out_sonic(16) = wnd_dir_sonic
Alias cov_out_sonic(17) = std_wnd_dir
Alias cov_out_sonic(18) = wnd_dir_compass
Units Hs = W/m^2
Units tau = kg/(m s^2)
Units u_star = m/s
Units Ts_stdev = C
Units Ts_Ux_cov = C m/s
Units Ts_Uy_cov = C m/s
Units Ts_Uz_cov = C m/s
Units Ux_stdev = m/s
Units Ux_Uy_cov = (m/s)^2
Units Ux_Uz_cov = (m/s)^2
Units Uy_stdev = m/s
Units Uy_Uz_cov = (m/s)^2
Units Uz_stdev = m/s
Units wnd_spd = m/s
Units rslt_wnd_spd = m/s
Units wnd_dir_sonic = degrees
Units std_wnd_dir = degrees
Units wnd_dir_compass = degrees

DataTable (delay_3d,TRUE,OFFSET)
  TableHide
  Sample (5,sonic_irga_raw(1),IEEE4)
EndTable

DataTable (comp_cov_3d,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  'Compute covariances from CSAT3B data.
  Covariance (4,cov_array_sonic(1,1),IEEE4,sonic_disable_f,10)
  WindVector (1,Uy,Ux,IEEE4,sonic_disable_f,0,1,2)
EndTable

DisplayMenu ("System Control",TRUE)
  MenuItem ("Sonic Azmth",sonic_azimuth)
EndMenu
'*** End of CSAT3B constants, variables, and working data table ***
#EndIf
#If ( SENSOR_IRGASON = TRUE ) Then


'*** Beginning of EC100 configure, zero, and span constants and variables, and subroutine ***
Const BANDWIDTH = 20            '10 = 10 Hz; 20 = 20 Hz
Const DIFFERENTIAL_PRESSURE = 0 '0 = disabled
Const TEMPERATURE_SOURCE = 0    '0 = ambient temperature sensor
Const AUTO_HEATER_CONTROL = -2  '-2 = automatic; -1 = off
Const BB = 0                    'BB = EC100 basic pressure transducer
Const EB = 2                    'EB = EC100 enhanced pressure transducer

Public CO2_span_gas
Public Td_span_gas

Dim config_array(4,2) = {0,BANDWIDTH,3,DIFFERENTIAL_PRESSURE,7,TEMPERATURE_SOURCE,18,AUTO_HEATER_CONTROL}
Dim power_array (1,2) = {21,0}
Dim press_source_array(1,2) = {2,0}   'Pressure source,basic pressure transducer (default).
Dim zero_array(1,2) = {11,1}          'Zero/Span command,set zero value.
Dim span_CO2_array(2,2) = {12,0,11,2} 'CO2 span concentration,0; Zero/Span command,set CO2 span value (default).
Dim span_H2O_array(2,2) = {13,0,11,3} 'H2O span dew point temperature,0; Zero/Span command,set H2O span value (default).
Dim config_result As Long

Public set_press_source_flg As Boolean
Public press_source As Long = 99999
Public do_zero_flg As Boolean
Public do_CO2_span_flg As Boolean
Public do_H2O_span_flg As Boolean
Public irga_off_flg As Boolean
Dim irga_off_bit As Boolean
Dim irga_startup_bit As Boolean
Dim configure_ec100_f As Boolean = TRUE
Dim irga_power_f As Boolean
Dim NAN_cnt As Long
Dim irga_off_flg_prev As Boolean
Dim sec_since_last_cmd


Sub Config (cmd_array(4,2),num_cmd As Long,retry_config_f As Boolean)
  Dim i As Long
  Dim config_result As Long
  Dim save_flash_f As Boolean = FALSE

  For i = 1 To num_cmd
    EC100Configure (config_result,1,cmd_array(i,1),cmd_array(i,2))
    If ( config_result = NAN ) Then ( ExitFor )
    If ( (cmd_array(i,1) = 2) OR (cmd_array(i,1) = 11) ) Then ( save_flash_f = TRUE )
  Next i

  If ( i = num_cmd+1 ) Then
    If ( save_flash_f ) Then ( EC100Configure (config_result,EC100_SDM_ADDR,99,2718) )
    If ( config_result <> NAN ) Then ( retry_config_f = FALSE )
  EndIf

  SetStatus ("SkippedScan",0)
EndSub
'*** End of EC100 configure, zero, and span constants and variables, and subroutine ***
#EndIf
#If ( (SENSOR_CSAT3 <> TRUE) AND (SENSOR_CSAT3B <> TRUE) ) Then


'*** Beginning of CSAT3A sonic head constants, variables, and working data table ***
Public sonic_azimuth                       'Enter sonic azimuth using keyboard after program has compiled (azimuth of the CSAT3(A) negative x-axis see Section 3.2.1 CSAT3A Azimuth in the OPEC manual).
Units sonic_azimuth = degrees

Public sonic(5)
Alias sonic(1) = Ux
Alias sonic(2) = Uy
Alias sonic(3) = Uz
Alias sonic(4) = Ts
Alias sonic(5) = diag_sonic
Public diag_sonic_aggregate As Long
Units Ux = m/s
Units Uy = m/s
Units Uz = m/s
Units Ts = C
Units diag_sonic = arb
Units diag_sonic_aggregate = arb

Dim diag_bits_sonic(6) As Long             'Sonic warning flags.
Alias diag_bits_sonic(1) = sonic_amp_l_f   'Amplitude low warning flag.
Alias diag_bits_sonic(2) = sonic_amp_h_f   'Amplitude high warning flag.
Alias diag_bits_sonic(3) = sonic_sig_lck_f 'Poor signal lock warning flag.
Alias diag_bits_sonic(4) = sonic_del_T_f   'Delta temperature warning flag.
Alias diag_bits_sonic(5) = sonic_aq_sig_f  'Sonic acquiring signals warning flag.
Alias diag_bits_sonic(6) = sonic_cal_err_f 'Signature error in reading CSAT3A sonic head calibration data.
Units diag_bits_sonic = arb
Dim diag_sonic_tmp As Long                 'Temporary variable used to break out the CSAT3A sonic head diagnostic bits.

Dim sonic_irga_raw(12)                     'EC150 w/CSAT3A sonic head (not lagged).

Dim sonic_disable_f As Boolean             'TRUE when CSAT3A sonic head diagnostic warning flags are on or CSAT3A sonic head has not sent data or an SDM signature error is reported.
Dim Ts_absolute                            'Sonic temperature (K).
Dim sonic_azimuth_prev

Dim cov_array_sonic(1,4)                   'Arrays used to hold the input data for the covariance instructions (CSAT3A sonic head).
Dim cov_out_sonic(18)                      'CSAT3A sonic head statistics.
Alias cov_out_sonic(1) = Hs                'Sensible heat flux using sonic temperature.
Alias cov_out_sonic(2) = tau               'Momentum flux.
Alias cov_out_sonic(3) = u_star            'Friction velocity.
Alias cov_out_sonic(4) = Ts_stdev
Alias cov_out_sonic(5) = Ts_Ux_cov
Alias cov_out_sonic(6) = Ts_Uy_cov
Alias cov_out_sonic(7) = Ts_Uz_cov
Alias cov_out_sonic(8) = Ux_stdev
Alias cov_out_sonic(9) = Ux_Uy_cov
Alias cov_out_sonic(10) = Ux_Uz_cov
Alias cov_out_sonic(11) = Uy_stdev
Alias cov_out_sonic(12) = Uy_Uz_cov
Alias cov_out_sonic(13) = Uz_stdev
Alias cov_out_sonic(14) = wnd_spd
Alias cov_out_sonic(15) = rslt_wnd_spd
Alias cov_out_sonic(16) = wnd_dir_sonic
Alias cov_out_sonic(17) = std_wnd_dir
Alias cov_out_sonic(18) = wnd_dir_compass
Units Hs = W/m^2
Units tau = kg/(m s^2)
Units u_star = m/s
Units Ts_stdev = C
Units Ts_Ux_cov = C m/s
Units Ts_Uy_cov = C m/s
Units Ts_Uz_cov = C m/s
Units Ux_stdev = m/s
Units Ux_Uy_cov = (m/s)^2
Units Ux_Uz_cov = (m/s)^2
Units Uy_stdev = m/s
Units Uy_Uz_cov = (m/s)^2
Units Uz_stdev = m/s
Units wnd_spd = m/s
Units rslt_wnd_spd = m/s
Units wnd_dir_sonic = degrees
Units std_wnd_dir = degrees
Units wnd_dir_compass = degrees

DataTable (delay_3d,TRUE,OFFSET)
  TableHide
  Sample (5,sonic_irga_raw(1),IEEE4)
EndTable

DataTable (comp_cov_3d,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  'Compute covariances from CSAT3A sonic head data.
  Covariance (4,cov_array_sonic(1,1),IEEE4,sonic_disable_f,10)
  WindVector (1,Uy,Ux,IEEE4,sonic_disable_f,0,1,2)
EndTable
'*** End of CSAT3A sonic head constants, variables, and working data table ***
#EndIf
#If ( SENSOR_IRGASON = TRUE ) Then


'*** Beginning of EC150 constants, variables, and working data table ***
Const DELAY_EC150 = INT (4000/SCAN_INTERVAL/BANDWIDTH) 'Automatically computed lag of the EC150 data.
Const EC150_REC_BCK = OFFSET-DELAY_EC150-1 'Number of records back to align EC150 data. Minus one scan because the SDM instruction is at the end of the program.

Public irga(11)
Alias irga(1) = CO2
Alias irga(2) = H2O
Alias irga(3) = diag_irga
Alias irga(4) = amb_tmpr
Alias irga(5) = amb_press
Alias irga(6) = CO2_sig_strgth
Alias irga(7) = H2O_sig_strgth
Alias irga(8) = Tc
Alias irga(9) = Td
Alias irga(10) = Xc
Alias irga(11) = Xv
Public diag_irga_aggregate As Long
Units CO2 = mg/m^3
Units H2O = g/m^3
Units diag_irga = arb
Units amb_tmpr = C
Units amb_press = kPa
Units CO2_sig_strgth = fraction
Units H2O_sig_strgth = fraction
Units Tc = C
Units Td = C
Units Xc = umol/mol
Units Xv = mmol/mol
Units diag_irga_aggregate = arb

Dim diag_bits_irga(22) As Long                   'Gas analyzer warning flags.
Alias diag_bits_irga(1) = irga_bad_data_f        'Gas analyzer bad data warning flag.
Alias diag_bits_irga(2) = irga_gen_fault_f       'General fault warning flag.
Alias diag_bits_irga(3) = irga_startup_f         'Gas analyzer starting up warning flag.
Alias diag_bits_irga(4) = irga_motor_spd_f       'Gas analyzer motor speed out of bounds warning flag.
Alias diag_bits_irga(5) = irga_tec_tmpr_f        'Thermoelectric cooler temperature out of bounds warning flag.
Alias diag_bits_irga(6) = irga_src_pwr_f         'Gas analyzer source power out of bounds warning flag.
Alias diag_bits_irga(7) = irga_src_tmpr_f        'Gas analyzer source temperature out of bounds warning flag.
Alias diag_bits_irga(8) = irga_src_curr_f        'Gas analyzer source current out of bounds warning flag.
Alias diag_bits_irga(9) = irga_off_f             'Gas analyzer head is powered down.
Alias diag_bits_irga(10) = irga_sync_f           'Gas analyzer not synchronized with home pulse warning flag.
Alias diag_bits_irga(11) = irga_amb_tmpr_f       'Invalid ambient temperature warning flag.
Alias diag_bits_irga(12) = irga_amb_press_f      'Invalid ambient pressure warning flag.
Alias diag_bits_irga(13) = irga_CO2_I_f          'CO2 I out of bounds warning flag.
Alias diag_bits_irga(14) = irga_CO2_Io_f         'CO2 Io out of bounds warning flag.
Alias diag_bits_irga(15) = irga_H2O_I_f          'H2O I out of bounds warning flag.
Alias diag_bits_irga(16) = irga_H2O_Io_f         'H2O Io out of bounds warning flag.
Alias diag_bits_irga(17) = irga_CO2_Io_var_f     'CO2 Io moving variation out of bounds warning flag.
Alias diag_bits_irga(18) = irga_H2O_Io_var_f     'H2O Io moving variation out of bounds warning flag.
Alias diag_bits_irga(19) = irga_CO2_sig_strgth_f 'CO2 signal strength warning flag.
Alias diag_bits_irga(20) = irga_H2O_sig_strgth_f 'H2O signal strength warning flag.
Alias diag_bits_irga(21) = irga_cal_err_f        'Gas analyzer calibration data signature error.
Alias diag_bits_irga(22) = irga_htr_ctrl_off_f   'Gas analyzer heater control disabled by EC100.
Units diag_bits_irga = arb
Dim diag_irga_tmp As Long                        'Temporary variable used to break out the gas analyzer diagnostic bits.

Dim divisor                                 'Temporary variable used to find molar mixing ratio.
Dim irga_disable_f As Boolean               'TRUE when EC150 sends bad data.
Dim sonic_irga_disable_f As Boolean         'TRUE when EC150 or CSAT3A sends bad data.
Dim rho_d_mean                              'Density of dry air used in Webb et al. term [g / m^3].
Dim sigma_wpl                               'Webb et al. sigma = density of water vapor / density of dry air.
Dim Td_tmp

Dim cov_array_cs(3,4)                       'Arrays used to hold the input data for the covariance instructions (EC150 and CSAT3A sonic head).
Dim cov_out_cs(26)                          'EC150 statistics.
Alias cov_out_cs(1) = Fc_wpl                'Carbon dioxide flux (EC150), with Webb et al. term.
Alias cov_out_cs(2) = LE_wpl                'Latent heat flux (EC150), with Webb et al. term.
Alias cov_out_cs(3) = Hc                    'Sensible heat flux using sonic temperature corrected for water vapor measured by the EC150.
Alias cov_out_cs(4) = CO2_stdev
Alias cov_out_cs(5) = CO2_Ux_cov
Alias cov_out_cs(6) = CO2_Uy_cov
Alias cov_out_cs(7) = CO2_Uz_cov
Alias cov_out_cs(8) = H2O_stdev
Alias cov_out_cs(9) = H2O_Ux_cov
Alias cov_out_cs(10) = H2O_Uy_cov
Alias cov_out_cs(11) = H2O_Uz_cov
Alias cov_out_cs(12) = Tc_stdev
Alias cov_out_cs(13) = Tc_Ux_cov
Alias cov_out_cs(14) = Tc_Uy_cov
Alias cov_out_cs(15) = Tc_Uz_cov
Alias cov_out_cs(16) = CO2_mean
Alias cov_out_cs(17) = H2O_mean
Alias cov_out_cs(18) = amb_press_mean
Alias cov_out_cs(19) = Tc_mean              'Sonic temperature corrected for humidity.
Alias cov_out_cs(20) = rho_a_mean
Alias cov_out_cs(21) = Fc_irga              'Carbon dioxide flux (EC150), without Webb et al. term.
Alias cov_out_cs(22) = LE_irga              'Latent heat flux (EC150), without Webb et al. term.
Alias cov_out_cs(23) = CO2_wpl_LE           'Carbon dioxide flux (EC150), Webb et al. term due to latent heat flux.
Alias cov_out_cs(24) = CO2_wpl_H            'Carbon dioxide flux (EC150), Webb et al. term due to sensible heat flux.
Alias cov_out_cs(25) = H2O_wpl_LE           'Latent heat flux (EC150), Webb et al. term due to latent heat flux.
Alias cov_out_cs(26) = H2O_wpl_H            'Latent heat flux (EC150), Webb et al. term due to sensible heat flux.
Units Fc_wpl = mg/(m^2 s)
Units LE_wpl = W/m^2
Units Hc = W/m^2
Units CO2_stdev = mg/m^3
Units CO2_Ux_cov = mg/(m^2 s)
Units CO2_Uy_cov = mg/(m^2 s)
Units CO2_Uz_cov = mg/(m^2 s)
Units H2O_stdev = g/m^3
Units H2O_Ux_cov = g/(m^2 s)
Units H2O_Uy_cov = g/(m^2 s)
Units H2O_Uz_cov = g/(m^2 s)
Units Tc_stdev = C
Units Tc_Ux_cov = C m/s
Units Tc_Uy_cov = C m/s
Units Tc_Uz_cov = C m/s
Units CO2_mean = mg/m^3
Units H2O_mean = g/m^3
Units amb_press_mean = kPa
Units Tc_mean = C
Units rho_a_mean = kg/m^3
Units Fc_irga = mg/(m^2 s)
Units LE_irga = W/m^2
Units CO2_wpl_LE = mg/(m^2 s)
Units CO2_wpl_H = mg/(m^2 s)
Units H2O_wpl_LE = W/m^2
Units H2O_wpl_H = W/m^2

DataTable (delay_cs,TRUE,OFFSET)
  TableHide
  Sample (7,sonic_irga_raw(6),IEEE4)
EndTable

DataTable (comp_cov_cs,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  'Compute covariance of CO2 against sonic wind data.
  Covariance (4,cov_array_cs(1,1),IEEE4,sonic_irga_disable_f,4)
  'Compute covariance of H2O against sonic wind data.
  Covariance (4,cov_array_cs(2,1),IEEE4,sonic_irga_disable_f,4)
  'Compute covariance of Tc (computed fast response temperature) against sonic wind data.
  Covariance (4,cov_array_cs(3,1),IEEE4,sonic_irga_disable_f,4)
  Average (2,CO2,IEEE4,irga_disable_f)
  Average (1,amb_press,IEEE4,FALSE)
  Average (1,Tc,IEEE4,sonic_irga_disable_f)
EndTable


DisplayMenu ("System Control",TRUE)
  MenuItem ("Sonic Azmth",sonic_azimuth)
  MenuItem ("IRGA Off",irga_off_flg)
    MenuPick (True,False)
  SubMenu ("Change Press Source")
    MenuItem ("Select Srce",press_source)
  MenuPick (BB,EB)
    MenuItem ("Set Source",set_press_source_flg)
  MenuPick (True)
  EndSubMenu
  SubMenu ("On Site Zero & Span")
    SubMenu ("Span Concentrations")
      MenuItem ("CO2",CO2_span_gas)
      MenuItem ("Td",Td_span_gas)
    EndSubMenu
    MenuItem ("Do Zero",do_zero_flg)
  MenuPick (True)
    MenuItem ("Do CO2 Span",do_CO2_span_flg)
  MenuPick (True)
    MenuItem ("Do H2O Span",do_H2O_span_flg)
  MenuPick (True)
    DisplayValue ("CO2 um/m dry",Xc)
    DisplayValue ("H2O mm/m dry",Xv)
    DisplayValue ("Td degrees C",Td)
  EndSubMenu
EndMenu
'*** End of EC150 constants, variables, and working data table ***
#EndIf
#If ( SENSOR_KH20 = TRUE ) Then


'*** Beginning of KH20 constants, variables, and working data table. ***
Const CO = 0.2095                     'Fraction concentration of oxygen in the atmosphere.
Const MO = 32                         'Molecular weight of oxygen [g/mol].
Const KO = 0.0045                     'Absorption coefficient for oxygen [m^3/(g cm)].

Public kh20(2)
Alias kh20(1) = kh
Alias kh20(2) = ln_kh
Units kh = mV
Units ln_kh = ln_mV

Dim sigma_wpl_kh                      'Webb et al. sigma = density of water vapor / density of dry air.

'Raw and not lagged KH20 data.
Dim kh_raw(2)

Dim cov_array_kh(5)                      'Arrays used to hold the input data for the covariance instructions (sonic and KH20).
Dim cov_out_kh(11)                       'KH20 statistics.
Alias cov_out_kh(1) = LE_kh_wpl          'Latent heat flux (KH20), with Webb et al. term.
Alias cov_out_kh(2) = H2O_kh_stdev
Alias cov_out_kh(3) = H2O_kh_Ux_cov
Alias cov_out_kh(4) = H2O_kh_Uy_cov
Alias cov_out_kh(5) = H2O_kh_Uz_cov
Alias cov_out_kh(6) = H2O_kh_Ts_cov
Alias cov_out_kh(7) = LE_kh              'Latent heat flux from KH20.
Alias cov_out_kh(8) = oc_LE              'Oxygen correction to the KH20 Latent heat flux.
Alias cov_out_kh(9) = oc_var             'Oxygen correction to the KH20 variance.
Alias cov_out_kh(10) = H2O_kh_wpl_LE_kh  'Latent heat flux (KH20), Webb et al. term due to latent heat flux.
Alias cov_out_kh(11) = H2O_kh_wpl_H_kh   'Latent heat flux (KH20), Webb et al. term due to sensible heat flux.
Units LE_kh_wpl = W/m^2
Units H2O_kh_stdev = g/m^3
Units H2O_kh_Ux_cov = g/(m^2 s)
Units H2O_kh_Uy_cov = g/(m^2 s)
Units H2O_kh_Uz_cov = g/(m^2 s)
Units H2O_kh_Ts_cov = g C/m^3
Units LE_kh = W/m^2
Units oc_LE = W/m^2
Units oc_var = (g/m^3)^2
Units H2O_kh_wpl_LE_kh = W/m^2
Units H2O_kh_wpl_H_kh = W/m^2

DataTable (delay_kh,TRUE,OFFSET)
  TableHide
  Sample (2,kh_raw(1),IEEE4)
EndTable

DataTable (comp_cov_kh,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  'Compute covariance of KH20 against sonic wind data.
  Covariance (5,cov_array_kh(1),IEEE4,sonic_disable_f OR (kh <= 0),5)
EndTable
'*** End of KH20 constants, variables, and working data table ***
#EndIf
#If ( SENSOR_FW = TRUE ) Then


'*** Beginning of FW05 constants, variables, and working data table ***
Public fw
Units fw = C

'Raw and not lagged FW05 data.
Dim fw_raw

Dim cov_array_fw(4)             'Arrays used to hold the input data for the covariance instructions (sonic and FW05).
Dim cov_out_fw(5)               'FW05 statistics.
Alias cov_out_fw(1) = H         'Sensible heat flux.
Alias cov_out_fw(2) = fw_stdev
Alias cov_out_fw(3) = fw_Ux_cov
Alias cov_out_fw(4) = fw_Uy_cov
Alias cov_out_fw(5) = fw_Uz_cov
Units H = W/m^2
Units fw_stdev = C
Units fw_Ux_cov = C m/s
Units fw_Uy_cov = C m/s
Units fw_Uz_cov = C m/s

DataTable (delay_fw,TRUE,OFFSET)
  TableHide
  Sample (1,fw_raw,IEEE4)
EndTable

DataTable (comp_cov_fw,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  'Compute covariance of FW05 against sonic wind data.
  Covariance (4,cov_array_fw(1),IEEE4,sonic_disable_f,4)
EndTable
'*** End of FW05 constants, variables, and working data table ***
#EndIf
#If ( SENSOR_LI7500 = TRUE ) Then


'*** Beginning of LI-7500(A) constants, variables, and working data table ***
'Set bandwidth to 20 Hz.
'Fixed inherent lag, set delay as close as possible to 300 ms.
Const DELAY_LI7500 = INT (300/SCAN_INTERVAL) 'Fixed inherent lag of the LI-7500(A) data (three scans at 10 Hz or six scans at 20 Hz).
Const LI7500_REC_BCK = OFFSET-DELAY_LI7500-1 'Number of records back to align LI-7500(A) data. Minua one scan because the SDM instruction is at the end of the program.

Public irga_li(8)
Alias irga_li(1) = CO2_li
Alias irga_li(2) = H2O_li
Alias irga_li(3) = amb_press_li
Alias irga_li(4) = agc_li
Alias irga_li(5) = diag_irga_li
Alias irga_li(6) = Tc_li
Alias irga_li(7) = Xc_li
Alias irga_li(8) = Xv_li
Public diag_irga_li_aggregate As Long
Units CO2_li = mg/m^3
Units H2O_li = g/m^3
Units amb_press_li = kPa
Units agc_li = %
Units diag_irga_li = arb
Units Tc_li = C
Units Xc_li = umol/mol
Units Xv_li = mmol/mol
Units diag_irga_li_aggregate = arb

Dim diag_bits_irga_li(4) As Long                'Infrared gas analyzer warning flags.
Alias diag_bits_irga_li(1) = irga_li_sync_f     'Synchronization warning flag.
Alias diag_bits_irga_li(2) = irga_li_pll_f      'PLL warning flag.
Alias diag_bits_irga_li(3) = irga_li_detector_f 'Detector warning flag.
Alias diag_bits_irga_li(4) = irga_li_chopper_f  'Chopper warning flag.
Dim diag_irga_li_tmp As Long                    'Temporary variable used to break out the LI-7500 diagnostic bits.

Dim divisor_li                          'Temporary variable used to find molar mixing ratio.
Dim irga_li_disable_f As Boolean        'TRUE when LI-7500(A) sends bad data.
Dim sonic_irga_li_disable_f As Boolean  'TRUE when LI-7500(A) or sonic sends bad data.
Dim rho_d_li_mean                       'Density of dry air used in Webb et al. term [kg / m^3].
Dim sigma_wpl_li                        'Webb et al. sigma = density of water vapor / density of dry air.

'Raw and not lagged LI-7500(A) data.
Dim irga_li_raw(5)

'LI-7500(A) output variables.
Dim cov_array_li(3,4)                   'Arrays used to hold the input data for the covariance instructions (sonic and LI-7500(A)).
Dim cov_out_li(26)                      'LI-7500(A) statistics.
Alias cov_out_li(1) = Fc_li_wpl         'Carbon dioxide flux (LI-7500(A)), with Webb et al. term.
Alias cov_out_li(2) = LE_li_wpl         'Latent heat flux (LI-7500(A)), with Webb et al. term.
Alias cov_out_li(3) = Hc_li             'Sensible heat flux using sonic temperature corrected for water vapor measured by the LI-7500(A).
Alias cov_out_li(4) = CO2_li_stdev
Alias cov_out_li(5) = CO2_li_Ux_cov
Alias cov_out_li(6) = CO2_li_Uy_cov
Alias cov_out_li(7) = CO2_li_Uz_cov
Alias cov_out_li(8) = H2O_li_stdev
Alias cov_out_li(9) = H2O_li_Ux_cov
Alias cov_out_li(10) = H2O_li_Uy_cov
Alias cov_out_li(11) = H2O_li_Uz_cov
Alias cov_out_li(12) = Tc_li_stdev
Alias cov_out_li(13) = Tc_li_Ux_cov
Alias cov_out_li(14) = Tc_li_Uy_cov
Alias cov_out_li(15) = Tc_li_Uz_cov
Alias cov_out_li(16) = CO2_li_mean
Alias cov_out_li(17) = H2O_li_mean
Alias cov_out_li(18) = amb_press_li_mean
Alias cov_out_li(19) = Tc_li_mean       'Sonic temperature corrected for humidity.
Alias cov_out_li(20) = rho_a_li_mean
Alias cov_out_li(21) = Fc_li_irga       'Carbon dioxide flux (LI-7500(A)), without Webb et al. term.
Alias cov_out_li(22) = LE_li_irga       'Latent heat flux (LI-7500(A)), without Webb et al. term.
Alias cov_out_li(23) = CO2_li_wpl_LE_li 'Carbon dioxide flux (LI-7500(A)), Webb et al. term due to latent heat flux.
Alias cov_out_li(24) = CO2_li_wpl_H_li  'Carbon dioxide flux (LI-7500(A)), Webb et al. term due to sensible heat flux.
Alias cov_out_li(25) = H2O_li_wpl_LE_li 'Latent heat flux (LI-7500(A)), Webb et al. term due to latent heat flux.
Alias cov_out_li(26) = H2O_li_wpl_H_li  'Latent heat flux (LI-7500(A)), Webb et al. term due to sensible heat flux.
Units Fc_li_wpl = mg/(m^2 s)
Units LE_li_wpl = W/m^2
Units Hc_li = W/m^2
Units CO2_li_stdev = mg/m^3
Units CO2_li_Ux_cov = mg/(m^2 s)
Units CO2_li_Uy_cov = mg/(m^2 s)
Units CO2_li_Uz_cov = mg/(m^2 s)
Units H2O_li_stdev = g/m^3
Units H2O_li_Ux_cov = g/(m^2 s)
Units H2O_li_Uy_cov = g/(m^2 s)
Units H2O_li_Uz_cov = g/(m^2 s)
Units Tc_li_stdev = C
Units Tc_li_Ux_cov = C m/s
Units Tc_li_Uy_cov = C m/s
Units Tc_li_Uz_cov = C m/s
Units CO2_li_mean = mg/m^3
Units H2O_li_mean = g/m^3
Units amb_press_li_mean = kPa
Units Tc_li_mean = C
Units rho_a_li_mean = kg/m^3
Units Fc_li_irga = mg/(m^2 s)
Units LE_li_irga = W/m^2
Units CO2_li_wpl_LE_li = mg/(m^2 s)
Units CO2_li_wpl_H_li = mg/(m^2 s)
Units H2O_li_wpl_LE_li = W/m^2
Units H2O_li_wpl_H_li = W/m^2

DataTable (delay_li,TRUE,OFFSET)
  TableHide
  Sample (5,irga_li_raw(1),IEEE4)
EndTable

DataTable (comp_cov_li,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  'Compute covariance of CO2_li against sonic wind data.
  Covariance (4,cov_array_li(1,1),IEEE4,sonic_irga_li_disable_f,4)
  'Compute covariance of H2O_li against sonic wind data.
  Covariance (4,cov_array_li(2,1),IEEE4,sonic_irga_li_disable_f,4)
  'Compute covariance of Tc_li (computed fast response temperature) against sonic wind data.
  Covariance (4,cov_array_li(3,1),IEEE4,sonic_irga_li_disable_f,4)
  Average (3,CO2_li,IEEE4,irga_li_disable_f)
  Average (1,Tc_li,IEEE4,sonic_irga_li_disable_f)
EndTable
'*** End of LI-7500(A) constants, variables, and working data table ***
#EndIf
#If ( SENSOR_TMPR_RH = TRUE ) Then


'*** Beginning of temperature and humidity probe constants, variables, and working data table. ***
Public tmpr_rh(3)
Alias tmpr_rh(1) = T_tmpr_rh                    'Temperature/humidity probe temperature.
Alias tmpr_rh(2) = RH_tmpr_rh                   'Temperature/humidity probe relative humidity.
Alias tmpr_rh(3) = e_tmpr_rh                    'Temperature/humidity probe vapor pressure.
Units T_tmpr_rh = C
Units RH_tmpr_rh = percent
Units e_tmpr_rh = kPa

Dim e_sat_tmpr_rh                               'Temperature/humidity probe saturation vapor pressure.
Dim rho_d_tmpr_rh_mean                          'Density of dry air used in Webb et al. term [kg / m^3].

Dim stats_out_tmpr_rh(6)                        'Temperature/humidity probe statistics.
Alias stats_out_tmpr_rh(1) = T_tmpr_rh_mean     'Mean temperature/humidity probe temperature.
Alias stats_out_tmpr_rh(2) = e_tmpr_rh_mean     'Mean temperature/humidity probe vapor pressure.
Alias stats_out_tmpr_rh(3) = e_sat_tmpr_rh_mean 'Mean temperature/humidity probe saturation vapor pressure.
Alias stats_out_tmpr_rh(4) = H2O_tmpr_rh_mean   'Mean temperature/humidity probe vapor density.
Alias stats_out_tmpr_rh(5) = RH_tmpr_rh_mean    'Mean temperature/humidity probe relative humidity.
Alias stats_out_tmpr_rh(6) = rho_a_tmpr_rh_mean 'Mean air density using Temperature/humidity probe measurements.
Units T_tmpr_rh_mean = C
Units e_tmpr_rh_mean = kPa
Units e_sat_tmpr_rh_mean = kPa
Units H2O_tmpr_rh_mean = g/m^3
Units RH_tmpr_rh_mean = %
Units rho_a_tmpr_rh_mean = kg/m^3

DataTable (stats_tmpr_rh,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  Average (1,T_tmpr_rh,IEEE4,slowsequence_disable_f)
  Average (1,e_tmpr_rh,IEEE4,slowsequence_disable_f)
  Average (1,e_sat_tmpr_rh,IEEE4,slowsequence_disable_f)
EndTable
'*** End of temperature and humidity probe constants, variables, and working data table ***
#EndIf
#If ( SENSOR_Q7_1 = TRUE ) Then


'*** Beginning of Q7.1 constants and variables ***
Const NMBR_WND_SAMPLES = 3000/SCAN_INTERVAL 'Number of points to compute a three second mean horizontal wind.
Public nr(2)
Dim hor_wind
Dim hor_wind_raw
Dim hor_wind_diag
Alias nr(1) = Rn
Alias nr(2) = Rn_meas
Units Rn = W/m^2
Units Rn_meas = W/^2
'*** End of Q7.1 constants and variables ***
#EndIf
#If ( SENSOR_NR_LITE_2 = TRUE ) Then


'*** Beginning of NR Lite 2 constants and variables ***
Const NMBR_WND_SAMPLES = 3000/SCAN_INTERVAL 'Number of points to compute a three second mean horizontal wind.
Public nr(2)
Dim hor_wind
Dim hor_wind_raw
Dim hor_wind_diag
Alias nr(1) = Rn
Alias nr(2) = Rn_meas
Units Rn = W/m^2
Units Rn_meas = W/m^2
'*** End of NR Lite 2 constants and variables ***
#EndIf
#If ( SENSOR_CNR_2 = TRUE ) Then


'*** Beginning of CNR 2 constants and variables ***
Public nr(3)
Alias nr(1) = Rn
Alias nr(2) = Rn_sw
Alias nr(3) = Rn_lw
Units nr = W/m^2
'*** End of CNR 2 constants and variables ***
#EndIf
#If ( SENSOR_NR_01_CNR_1 = TRUE ) Then


'*** Beginning of NR 01/CNR 1 constants and variables ***
Public nr(9)                           'CNR 1 net radiometer.
Alias nr(1) = Rn
Alias nr(2) = albedo
Alias nr(3) = Rs_incoming
Alias nr(4) = Rs_outgoing
Alias nr(5) = Rl_incoming
Alias nr(6) = Rl_outgoing
Alias nr(7) = T_nr
Alias nr(8) = Rl_incoming_meas
Alias nr(9) = Rl_outgoing_meas
Units nr = W/m^2
Units albedo = arb
Units T_nr = K
'*** End of NR 01/CNR 1 constants and variables ***
#EndIf
#If ( SENSOR_CNR_4 = TRUE ) Then


'*** Beginning of CNR 4 constants and variables ***
'YSI 44031 Steinhart-Hart coefficients fit through -40 degrees C (239800 ohms), 20 degrees C (12260 ohms), and 80 degrees C (1458 ohms).
Const A_SHH = 1.026613e-3              'Steinhart-Hart A coefficient.
Const B_SHH = 2.395424e-4              'Steinhart-Hart B coefficient.
Const C_SHH = 1.552561e-7              'Steinhart-Hart C coefficient.
Public nr(9)                           'CNR 4 net radiometer.
Dim X_cnr4
Dim ln_R
Alias nr(1) = Rn
Alias nr(2) = albedo
Alias nr(3) = Rs_incoming
Alias nr(4) = Rs_outgoing
Alias nr(5) = Rl_incoming
Alias nr(6) = Rl_outgoing
Alias nr(7) = T_nr
Alias nr(8) = Rl_incoming_meas
Alias nr(9) = Rl_outgoing_meas
Units nr = W/m^2
Units albedo = arb
Units T_nr = K
'*** End of CNR 4 constants and variables ***
#EndIf
#If (SENSOR_LI200X = TRUE ) Then


'*** Beginning of LI-200X constants and variables ***
Public Rs_incoming
Units Rs_incoming = W/m^2
'*** End of LI-200X constants and variables ***
#EndIf
#If (SENSOR_CS300 = TRUE ) Then


'*** Beginning of CS300 constants and variables ***
Public Rs_incoming
Units Rs_incoming = W/m^2
'*** End of LI-CS300 constants and variables ***
#EndIf
#If (SENSOR_LI190SB = TRUE ) Then


'*** Beginning of LI-190SB constants and variables ***
Public par
Units par = umol/m^2/s
'*** End of LI-190SB constants and variables ***
#EndIf
#If ( SENSOR_TCAV = TRUE ) Then


'*** Beginning of TCAV constants and variables ***
Public Tsoil(NMBR_TCAV)                'TCAV soil thermocouples.
Public del_Tsoil(NMBR_TCAV)            'Change in soil temperature.
Dim prev_Tsoil(NMBR_TCAV)
Dim Tsoil_mean(NMBR_TCAV)
Units Tsoil_mean = C
Units del_Tsoil = C

DataTable (stats_soil,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  Average (NMBR_TCAV,Tsoil(1),IEEE4,slowsequence_disable_f)
EndTable
'*** End of TCAV constants and variables ***
#EndIf
#If ( SENSOR_CS616 = TRUE ) Then


'*** Beginning of CS616 constants and variables ***
Const A0_CS616 = -0.0663               'CS616 a0 coefficient (generic value = -0.0663).
Const A1_CS616 = -0.0063               'CS616 a1 coefficient (generic value = -0.0063).
Const A2_CS616 =  0.0007               'CS616 a2 coefficient (generic value =  0.0007).
Public cs616_wcr(NMBR_CS616)           'Water content reflectometer period.
Public soil_water(NMBR_CS616)          'Volumetric soil water content without temperature correction.
Public soil_water_T(NMBR_CS616)        'Volumetric soil water content with temperature correction.
Dim cs616_T(NMBR_CS616)                'Water content reflectometer period with temperature correction.
Units cs616_wcr = uSeconds
Units soil_water = frac_v_wtr
Units soil_water_T = frac_v_wtr
'*** End of CS616 constants and variables ***
#EndIf
#If ( SENSOR_CS65X = TRUE ) Then


'*** Beginning of CS65X constants and variables ***
Public cs65x_wcr(NMBR_CS65X)           'Volumetric soil water content.
Public cs65x_ec(NMBR_CS65X)            'Electrical conductivity.
Public cs65x_tmpr(NMBR_CS65X)          'CS65X probe temperature.
Dim cs65x_raw(3)
Units cs65x_wcr = frac_v_wtr
Units cs65x_ec = dS/m
Units cs65x_tmpr = C
'*** End of CS65X constants and variables ***
#EndIf
#If ( SENSOR_HFT3 = TRUE ) Then


'*** Beginning of HFT3 constants and variables ***
Public shf(NMBR_SHF)
Dim shf_cal(NMBR_SHF)
Units shf = W/m^2
'*** End of HFT3 constants and variables ***
#EndIf
#If ( SENSOR_HFP01 = TRUE ) Then


'*** Beginning of HFP01 constants and variables ***
Public shf(NMBR_SHF)                   'HFP01 soil heat flux plates.
Dim shf_cal(NMBR_SHF)
Units shf = W/m^2
'*** End of HFP01 constants and variables ***
#EndIf
#If ( SENSOR_HFP01SC = TRUE ) Then


'*** Beginning of HFP01SC constants and variables ***
Const CAL_INTERVAL = 1440              'HFP01SC insitu calibration interval (minutes).
Const END_CAL = OUTPUT_INTERVAL-1      'End HFP01SC insitu calibration one minute before the next output.
Const SHF_REPS = 2*NMBR_SHF
Public shf(NMBR_SHF)                   'HFP01SC soil heat flux plates.
Dim shf_mV_raw(NMBR_SHF,2)             'Raw HFP01SC and V_Rf measurement.
Dim shf_cal(NMBR_SHF)
Dim shf_mV(NMBR_SHF)
Dim shf_mV_0(NMBR_SHF)
Dim shf_mV_180(NMBR_SHF)
Dim shf_mV_end(NMBR_SHF)
Dim V_Rf(NMBR_SHF)
Dim V_Rf_180(NMBR_SHF)
Dim shf_cal_on_f As Boolean
Dim sw12_1_state As Boolean            'State of the switched 12Vdc port 1.
Units shf = W/m^2
Units shf_cal = W/(m^2 mV)
'*** End of HFP01SC constants and variables ***
#EndIf
#If ( SENSOR_SI_111 = TRUE ) Then


'*** Beginning of SI-111 constants and variables ***
Const A_SHH_SI_111 = 1.130385e-3       'Steinhart-Hart A coefficient.
Const B_SHH_SI_111 = 2.339057e-4       'Steinhart-Hart B coefficient.
Const C_SHH_SI_111 = 8.862834e-8       'Steinhart-Hart C coefficient.

Public ir_tmpr
Public si_body_tmpr
Dim Rs
Dim X_si_111
Dim ln_Rs_si_111
Dim m
Dim b
Units ir_tmpr = C
Units si_body_tmpr = C
'*** End of SI-111 constants and variables ***
#EndIf
#If ( SENSOR_TE525 = TRUE ) Then


'*** Beginning of TE525 variable ***
Public precip
Units precip = mm
'*** End of TE525 variable ***
#EndIf


'*** Output data tables ***
DataTable (flux,TRUE,FLUX_SIZE_CPU)
  DataInterval (0,OUTPUT_INTERVAL,Min,10)
  CardOut (0,FLUX_SIZE_CRD)
  #If ( SENSOR_CSAT3 = TRUE ) Then

  '*** Beginning of CSAT3 output data ***
  Sample (18,Hs,IEEE4)
  Average (4,Ux,IEEE4,sonic_disable_f)
  Sample (1,sonic_azimuth,IEEE4)
  Totalize (1,n,IEEE4,sonic_disable_f)
  FieldNames ("sonic_samples_Tot")
  Sample (1,diag_sonic_aggregate,IEEE4)
  #If ( FIND_DIAG_BITS = TRUE )
  Totalize (1,n,IEEE4,(diag_sonic<>NAN) OR (diag_sonic<>61503))
  FieldNames ("no_new_sonic_data_Tot")
  Totalize (1,n,IEEE4,diag_sonic<>61441)
  FieldNames ("sig_error_Tot")
  Totalize (1,sonic_amp_l_f,IEEE4,FALSE)
  Totalize (1,sonic_amp_h_f,IEEE4,FALSE)
  Totalize (1,sonic_sig_lck_f,IEEE4,FALSE)
  Totalize (1,sonic_del_T_f,IEEE4,FALSE)
  #EndIf
  '*** End of CSAT3 output data ***
  #EndIf
  #If ( SENSOR_CSAT3B = TRUE ) Then
  '*** Beginning of CSAT3B output data ***
  Sample (18,Hs,IEEE4)
  Average (4,Ux,IEEE4,sonic_disable_f)
  Sample (1,sonic_azimuth,IEEE4)
  Totalize (1,n,IEEE4,sonic_disable_f)
  FieldNames ("sonic_samples_Tot")
  Sample (1,diag_sonic_aggregate,IEEE4)
  #If ( FIND_DIAG_BITS = TRUE )
  Totalize (1,n,IEEE4,diag_sonic<>NAN)
  FieldNames ("no_new_sonic_data_Tot")
  Totalize (1,sonic_amp_l_f,IEEE4,FALSE)
  Totalize (1,sonic_amp_h_f,IEEE4,FALSE)
  Totalize (1,sonic_sig_lck_f,IEEE4,FALSE)
  Totalize (1,sonic_del_T_f,IEEE4,FALSE)
  Totalize (1,sonic_aq_sig_f,IEEE4,FALSE)
  Totalize (1,sonic_low_volt_f,IEEE4,FALSE)
  Totalize (1,sonic_trig_f,IEEE4,FALSE)
  Totalize (1,sonic_intrnl_hmdty_f,IEEE4,FALSE)
  Totalize (1,sonic_cal_err_f,IEEE4,FALSE)
  #EndIf
  '*** End of CSAT3B output data ***
  #EndIf
  #If ( (SENSOR_CSAT3 <> TRUE) AND (SENSOR_CSAT3B <> TRUE) ) Then

  '*** Beginning of CSAT3A sonic head output data ***
  Sample (18,Hs,IEEE4)
  Average (4,Ux,IEEE4,sonic_disable_f)
  Sample (1,sonic_azimuth,IEEE4)
  Totalize (1,n,IEEE4,sonic_disable_f)
  FieldNames ("sonic_samples_Tot")
  Sample (1,diag_sonic_aggregate,IEEE4)
  #If ( FIND_DIAG_BITS = TRUE )
  Totalize (1,n,IEEE4,diag_sonic<>-1)
  FieldNames ("no_sonic_head_Tot")
  Totalize (1,n,IEEE4,diag_sonic<>NAN)
  FieldNames ("no_new_sonic_data_Tot")
  Totalize (1,sonic_amp_l_f,IEEE4,FALSE)
  Totalize (1,sonic_amp_h_f,IEEE4,FALSE)
  Totalize (1,sonic_sig_lck_f,IEEE4,FALSE)
  Totalize (1,sonic_del_T_f,IEEE4,FALSE)
  Totalize (1,sonic_aq_sig_f,IEEE4,FALSE)
  Totalize (1,sonic_cal_err_f,IEEE4,FALSE)
  #EndIf
  '*** End of CSAT3A sonic head output data ***
  #EndIf
  #If ( SENSOR_IRGASON = TRUE ) Then

  '*** Beginning of EC150 output data ***
  Sample (17,Fc_wpl,IEEE4)
  Average (1,amb_tmpr,IEEE4,FALSE)
  Sample (9,amb_press_mean,IEEE4)
  Totalize (1,n,IEEE4,irga_disable_f)
  FieldNames ("irga_samples_Tot")
  Sample (1,diag_irga_aggregate,IEEE4)
  #If ( FIND_DIAG_BITS = TRUE )
  Totalize (1,n,IEEE4,diag_irga<>-1)
  FieldNames ("no_irga_head_Tot")
  Totalize (1,n,IEEE4,diag_irga<>NAN)
  FieldNames ("no_new_irga_data_Tot")
  Totalize (1,irga_bad_data_f,IEEE4,FALSE)
  Totalize (1,irga_gen_fault_f,IEEE4,FALSE)
  Totalize (1,irga_startup_f,IEEE4,FALSE)
  Totalize (1,irga_motor_spd_f,IEEE4,FALSE)
  Totalize (1,irga_tec_tmpr_f,IEEE4,FALSE)
  Totalize (1,irga_src_pwr_f,IEEE4,FALSE)
  Totalize (1,irga_src_tmpr_f,IEEE4,FALSE)
  Totalize (1,irga_src_curr_f,IEEE4,FALSE)
  Totalize (1,irga_off_f,IEEE4,FALSE)
  Totalize (1,irga_sync_f,IEEE4,FALSE)
  Totalize (1,irga_amb_tmpr_f,IEEE4,FALSE)
  Totalize (1,irga_amb_press_f,IEEE4,FALSE)
  Totalize (1,irga_CO2_I_f,IEEE4,FALSE)
  Totalize (1,irga_CO2_Io_f,IEEE4,FALSE)
  Totalize (1,irga_H2O_I_f,IEEE4,FALSE)
  Totalize (1,irga_H2O_Io_f,IEEE4,FALSE)
  Totalize (1,irga_CO2_Io_var_f,IEEE4,FALSE)
  Totalize (1,irga_H2O_Io_var_f,IEEE4,FALSE)
  Totalize (1,irga_CO2_sig_strgth_f,IEEE4,FALSE)
  Totalize (1,irga_H2O_sig_strgth_f,IEEE4,FALSE)
  Totalize (1,irga_cal_err_f,IEEE4,FALSE)
  Totalize (1,irga_htr_ctrl_off_f,IEEE4,FALSE)
  #EndIf
  Average (1,CO2_sig_strgth,IEEE4,FALSE)
  FieldNames ("CO2_sig_strgth_mean")
  Average (1,H2O_sig_strgth,IEEE4,FALSE)
  FieldNames ("H2O_sig_strgth_mean")
  Totalize (1,n,IEEE4,CO2_sig_strgth>CO2_SIG_STRGTH_THRESHOLD)
  FieldNames ("CO2_sig_strgth_Tot")
  Totalize (1,n,IEEE4,H2O_sig_strgth>H2O_SIG_STRGTH_THRESHOLD)
  FieldNames ("H2O_sig_strgth_Tot")
  '*** End of EC150 output data ***
  #EndIf
  #If ( SENSOR_KH20 = TRUE ) Then

  '*** Beginning of KH20 output data ***
  Sample (11,LE_kh_wpl,IEEE4)
  Average (2,kh,IEEE4,kh<=0)
  Totalize (1,n,IEEE4,sonic_disable_f OR (kh<=0))
  FieldNames ("kh_samples_Tot")
  Totalize (1,n,IEEE4,kh>0)
  FieldNames ("kh_no_signal_Tot")
  '*** End of KH20 output data ***
  #EndIf
  #If ( SENSOR_FW = TRUE ) Then

  '*** Beginning of FW05 output data ***
  Sample (5,H,IEEE4)
  Average (1,fw,IEEE4,FALSE)
  Totalize (1,n,IEEE4,sonic_disable_f)
  FieldNames ("fw_samples_Tot")
  '*** End of FW05 output data ***
  #EndIf
  #If ( SENSOR_LI7500 = TRUE ) Then

  '*** Beginning of LI-7500(A) output data ***
  Sample (26,Fc_li_wpl,IEEE4)
  Totalize (1,n,IEEE4,irga_li_disable_f)
  FieldNames ("irga_li_samples_Tot")
  Sample (1,diag_irga_li_aggregate,IEEE4)
  #If ( FIND_DIAG_BITS = TRUE ) Then
  Totalize (1,n,IEEE4,CO2_li<>NAN)
  FieldNames ("no_new_data_li_Tot")
  Totalize (1,n,IEEE4,CO2_li<>-99999)
  FieldNames ("sig_error_li_Tot")
  #EndIf
  Average (1,agc_li,IEEE4,H2O_li=NAN)
  Totalize (1,n,IEEE4,(agc_li>=AGC_THRESHOLD) IMP (H2O_li=NAN))
  FieldNames ("agc_thrshld_excded_Tot")
  '*** End of LI-7500(A) output data ***
  #EndIf
  #If ( SENSOR_TMPR_RH = TRUE ) Then

  '*** Beginning of temperature and humidity probe output data ***
  Sample (6,T_tmpr_rh_mean,IEEE4)
  '*** End of temperature and humidity probe output data ***
  #EndIf
  #If ( SENSOR_Q7_1 = TRUE ) Then

  '*** Beginning of Q7.1 output data ***
  Average (2,Rn,IEEE4,slowsequence_disable_f)
  '*** End of Q7.1 output data ***
  #EndIf
  #If ( SENSOR_NR_LITE_2 = TRUE ) Then

  '*** Beginning of NR Lite 2 output data ***
  Average (2,Rn,IEEE4,slowsequence_disable_f)
  '*** End of NR Lite 2 output data ***
  #EndIf
  #If ( SENSOR_CNR_2 = TRUE ) Then

  '*** Beginning of CNR_2 output data ***
  Average (3,Rn,IEEE4,slowsequence_disable_f)
  '*** End of CNR 2 output data ***
  #EndIf
  #If ( SENSOR_NR_01_CNR_1 = TRUE ) Then

  '*** Beginning of NR 01/CNR 1 output data ***
  Average (9,Rn,IEEE4,slowsequence_disable_f)
  '*** End of NR 01/CNR 1 output data ***
  #EndIf
  #If ( SENSOR_CNR_4 = TRUE ) Then

  '*** Beginning of CNR 4 output data ***
  Average (9,Rn,IEEE4,slowsequence_disable_f)
  '*** End of CNR 4 output data ***
  #EndIf
  #If ( SENSOR_LI200X = TRUE ) Then

  '*** Beginning of LI-200X output data ***
  Average (1,Rs_incoming,IEEE4,slowsequence_disable_f)
  '*** End of LI-200X output data ***
  #EndIf
  #If ( SENSOR_CS300 = TRUE ) Then

  '*** Beginning of CS300 output data ***
  Average (1,Rs_incoming,IEEE4,slowsequence_disable_f)
  '*** End of CS300 output data ***
  #EndIf
  #If ( SENSOR_LI190SB = TRUE ) Then

  '*** Beginning of LI-190SB output data ***
  Average (1,par,IEEE4,slowsequence_disable_f)
  '*** End of LI-190SB output data ***
  #EndIf
  #If ( SENSOR_TCAV = TRUE ) Then

  '*** Beginning of TCAV output data ***
  Sample (NMBR_TCAV,Tsoil_mean(1),IEEE4)
  Sample (NMBR_TCAV,del_Tsoil(1),IEEE4)
  '*** End of TCAV output data ***
  #EndIf
  #If ( SENSOR_CS616 = TRUE ) Then

  '*** Beginning of CS616 output data ***
  Average (NMBR_CS616,soil_water(1),IEEE4,slowsequence_disable_f)
  Average (NMBR_CS616,soil_water_T(1),IEEE4,slowsequence_disable_f)
  Average (NMBR_CS616,cs616_wcr(1),IEEE4,slowsequence_disable_f)
  '*** End of CS616 output data ***
  #EndIf
  #If ( SENSOR_CS65X = TRUE ) Then

  '*** Beginning of CS65X output data ***
  Average (NMBR_CS65X,cs65x_wcr(1),IEEE4,slowsequence_disable_f)
  Average (NMBR_CS65X,cs65x_ec(1),IEEE4,slowsequence_disable_f)
  Average (NMBR_CS65X,cs65x_tmpr(1),IEEE4,slowsequence_disable_f)
  '*** End of CS65X output data ***
  #EndIf
  #If ( SENSOR_HFT3 = TRUE ) Then

  '*** Beginning of HFT3 output data ***
  Average (NMBR_SHF,shf(1),IEEE4,slowsequence_disable_f)
  '*** End of HFT3 output data ***
  #EndIf
  #If ( SENSOR_HFP01 = TRUE ) Then

  '*** Beginning of HFP01 output data ***
  Average (NMBR_SHF,shf(1),IEEE4,slowsequence_disable_f)
  '*** End of HFP01 output data ***
  #EndIf
  #If ( SENSOR_HFP01SC = TRUE ) Then

  '*** Beginning of HFP01SC output data ***
  Average (NMBR_SHF,shf(1),IEEE4,shf_cal_on_f OR slowsequence_disable_f)
  Sample (NMBR_SHF,shf_cal(1),IEEE4)
  '*** End of HFP01SC output data ***
  #EndIf
  #If ( SENSOR_SI_111 = TRUE ) Then

  '*** Beginning of SI-111 output data ***
  Average (1,ir_tmpr,IEEE4,slowsequence_disable_f)
  Average (1,si_body_tmpr,IEEE4,slowsequence_disable_f)
  '*** End of SI-111 output data ***
  #EndIf
  #If ( SENSOR_TE525 = TRUE ) Then

  '*** Beginning of TE525 output data ***
  Totalize (1,precip,IEEE4,FALSE)
  '*** End of TE525 output data ***
  #EndIf

  '*** Beginning of other output data ***
  Average (1,panel_tmpr,IEEE4,FALSE)
  Average (1,batt_volt,IEEE4,slowsequence_disable_f)
  Average (1,process_time,IEEE4,FALSE)
  Maximum (1,process_time,IEEE4,FALSE,FALSE)
  Maximum (1,buff_depth,IEEE4,FALSE,FALSE)
  '*** End of other output data ***

  Totalize (1,n,IEEE4,slowsequence_disable_f)
  FieldNames ("slowsequence_Tot")
EndTable

'Diagnostic data.
DataTable (diagnostic,TRUE,1)
  #If ( SENSOR_CSAT3 = TRUE ) Then
  Sample (4,sonic_amp_l_f,Boolean)
  #Else
  Sample (6,sonic_amp_l_f,Boolean)
  #EndIf
  #If ( SENSOR_IRGASON = TRUE ) Then
  Sample (22,irga_bad_data_f,Boolean)
  Sample (1,irga_off_bit,Boolean)
  Sample (1,irga_startup_bit,Boolean)  
  #EndIf
  #If ( SENSOR_LI7500 = TRUE ) Then
  Sample (4,irga_li_sync_f,Boolean)
  #EndIf
EndTable


'System log.
DataTable (sys_log,TRUE,128)
  CardOut (0,1024)

  Sample (1,err_message_str,String)
  FieldNames ("Message")
  Sample (2,curr_value_str,String)
  FieldNames ("Current Value,Previous Value")
EndTable


'Time series data.
DataTable (ts_data,TRUE,-1)
  DataInterval (0,SCAN_INTERVAL,mSec,100)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&".ts_data_",64,-1,0,1,Day,0,0)

  '*** Beginning of sonic time series output ***
  Sample (5,sonic_irga_raw(1),IEEE4)
  FieldNames ("Ux,Uy,Uz,Ts,diag_sonic")
  '*** End of sonic time series output ***

  #If ( SENSOR_IRGASON = TRUE ) Then
  '*** Beginning of EC150 time series output ***
  Sample (7,sonic_irga_raw(6),IEEE4)
  FieldNames ("CO2,H2O,diag_irga,amb_tmpr,amb_press,CO2_sig_strgth,H2O_sig_strgth")
  '*** End of EC150 time series output ***
  #EndIf
  #If ( SENSOR_KH20 = TRUE ) Then

  '*** Beginning of KH20 time series output ***
  Sample (2,kh_raw(1),IEEE4)
  FieldNames ("kh,ln_kh")
  Sample (1,T_tmpr_rh,IEEE4)
  Sample (1,e_tmpr_rh,IEEE4)
  '*** End of KH20 time series output ***
  #EndIf
  #If ( SENSOR_FW = TRUE ) Then

  '*** Beginning of FW05 time series output ***
  Sample (1,fw_raw,IEEE4)
  FieldNames ("fw")
  '*** End of FW05 time series output ***
  #EndIf
  #If ( SENSOR_LI7500 = TRUE ) Then

  '*** Beginning of LI-7500(A) time series output ***
  Sample (4,irga_li_raw(1),IEEE4)
  FieldNames ("CO2_li,H2O_li,amb_press_li,agc_li")
  '*** End of LI-7500(A) time series output ***
  #EndIf
EndTable



'*** Program ***

BeginProg
  #If ( (SENSOR_HFT3 = TRUE) OR (SENSOR_HFP01 = TRUE) OR (SENSOR_HFP01SC = TRUE) ) Then
  'Load NMBR_SHF plate calibration.
  For i = 1 To NMBR_SHF
    Read shf_cal(i)
  Next i

  #EndIf
  SemaphoreGet (1)
  sys_conf_var_file = FileOpen ("CPU:sys_conf_var.dat","rb",0) 'Check if a file exists.
  sys_conf_var_file_size = FileSize (sys_conf_var_file)
  FileClose (sys_conf_var_file)
  SemaphoreRelease (1)

  Select Case sys_conf_var_file_size
  Case Is = 0                                            'System configuration file does not exist.
    Calfile (sys_conf_var(1),2,"CPU:sys_conf_var.dat",0) 'Store the default values to the file.
  Case Is = 6                                            'Load v3.1 system configuration file size (6 bytes).
    Calfile (sys_conf_var(1),1,"CPU:sys_conf_var.dat",1) 'Read the values from the file.
  Case Is = 10                                           'Load v3.2 system configuration file size (10 bytes).
    Calfile (sys_conf_var(1),2,"CPU:sys_conf_var.dat",1) 'Read the values from the file.
  EndSelect

  sonic_azimuth = sys_conf_var(1)
  sonic_azimuth_prev = sonic_azimuth
  #If ( SENSOR_IRGASON = TRUE ) Then

  irga_off_flg = sys_conf_var(2)
  irga_off_flg_prev = irga_off_flg
  #EndIf

  'Set the SDM clock speed.
  SDMSpeed (SDM_PER)
  Scan (SCAN_INTERVAL,mSec,SCAN_BUFFER_SIZE,0)
    #If ( SENSOR_IRGASON = TRUE ) Then
    'Datalogger panel temperature.
    PanelTemp (panel_tmpr,250)


    '*** Beginning of EC150 w/ CSAT3A sonic head measurement processing ***
    If ( sonic_irga_raw(8) = NAN ) Then 'The EC150 diagnostic word (diag_irga) is sonic_irga_raw(8).
      NAN_cnt += 1
      configure_ec100_f = FALSE
    Else
      If ( NAN_cnt > 4 ) Then ( configure_ec100_f = TRUE )
      NAN_cnt = 0
    EndIf

    If ( configure_ec100_f ) Then
      Call Config (config_array(1,1),4,configure_ec100_f)
    ElseIf ( irga_power_f ) Then
      Call Config (power_array(1,1),1,irga_power_f)
    ElseIf ( set_press_source_flg ) Then
      press_source_array(1,2) = press_source
      Call Config (press_source_array(1,1),1,set_press_source_flg)
      If ( NOT (set_press_source_flg) ) Then ( EC100Configure (config_result,EC100_SDM_ADDR,99,2718) )
    ElseIf ( do_zero_flg ) Then
      Call Config (zero_array(1,1),1,do_zero_flg)
    ElseIf ( do_CO2_span_flg ) Then
      span_CO2_array(1,2) = CO2_span_gas
      Call Config (span_CO2_array(1,1),2,do_CO2_span_flg)
    ElseIf ( do_H2O_span_flg )
      span_H2O_array(1,2) = Td_span_gas
      Call Config (span_H2O_array(1,1),2,do_H2O_span_flg)
    EndIf

    diag_irga_tmp = IIF ((sonic_irga_raw(8) <> NAN) AND (sonic_irga_raw(8) <> -1),diag_irga,&h3ffefb)
    irga_off_bit = diag_irga_tmp AND &h000100
    irga_startup_bit = diag_irga_tmp AND &h000004

    #If ( (SENSOR_CSAT3 = FALSE) AND (SENSOR_CSAT3B = FALSE) ) Then
    CallTable delay_3d
    #EndIf
    CallTable delay_cs
    '*** End of EC150 w/ CSAT3A sonic head measurement processing ***
    #EndIf
    #If ( (SENSOR_CSAT3 = TRUE) OR (SENSOR_CSAT3B = TRUE) ) Then
    'Datalogger panel temperature.
    PanelTemp (panel_tmpr,250)


    '*** Beginning of soinc measurement processing ***
    CallTable delay_3d
    '*** End of sonic measurement processing ***
    #EndIf
    #If ( SENSOR_KH20 = TRUE ) Then


    '*** Beginning of KH20 measurements ***
    VoltDiff (kh_raw(1),1,mV5000,KH_ANALOG_INPUT,TRUE,450,250,1,0)
    kh_raw(2) = LOG (kh_raw(1))

    CallTable delay_kh
    '*** End of KH20 measurements ***
    #EndIf
    #If ( SENSOR_FW = TRUE ) Then


    '*** Beginning of FW05 measurements ***
    TCDiff (fw_raw,1,mV20,FW_ANALOG_INPUT,TypeE,panel_tmpr,TRUE,450,250,1,0)
    CallTable delay_fw
    '*** End of FW05 measurements ***
    #EndIf
    #If ( SENSOR_LI7500 = TRUE ) Then


    '*** Beginning of LI-7500(A) measurement processing ***
    'Convert LI-7500(A) data from molar density [mmol/m^3] to mass density.
    ' 44 [g/mol] - molecular weight of carbon dioxide
    ' 0.01802 [g/mmol] - molecular weight of water vapor
    If ( irga_li_raw(1) <> -99999 ) Then ( irga_li_raw(1) = irga_li_raw(1)*44 )
    irga_li_raw(2) = irga_li_raw(2)*0.01802

    'Extract LI-7500(A) diagnostic bits.
    irga_li_raw(5) = (irga_li_raw(4) AND &hf0)

    'Compute the AGC.
    irga_li_raw(4) = (irga_li_raw(4) AND &hf)*6.67

    CallTable delay_li
    '*** End of LI-7500(A) measurement processing ***
    #EndIf
    #If ( (SENSOR_Q7_1 = TRUE) OR (SENSOR_NR_LITE_2 = TRUE) ) Then


    '*** Beginning of Q7.1 or NR Lite 2 processing ***
    hor_wind_raw = SQR (sonic_irga_raw(1)*sonic_irga_raw(1)+sonic_irga_raw(2)*sonic_irga_raw(2))
    AvgRun (hor_wind,1,hor_wind_raw,NMBR_WND_SAMPLES) 'Maintain a three second running mean of horizontal wind.
    AvgRun (hor_wind_diag,1,sonic_irga_raw(5),NMBR_WND_SAMPLES) 'Maintain a three second running mean of horizontal wind.
    '*** End of Q7.1 or NR Lite 2 processing ***
    #EndIf
    #If ( SENSOR_TE525 = TRUE ) Then


    '*** Beginning of TE525 measurement ***
    PulseCount (precip,1,PRECIP_PULSE_INPUT,2,0,PRECIP_CAL,0)
    '*** End of TE525 measurement ***
    #EndIf


    'Save time series data.
    CallTable ts_data


    If ( scan_count >= OFFSET ) Then
      #If ( SENSOR_CSAT3 = TRUE ) Then
      '*** Beginning of CSAT3 processing ***
      'Load in CSAT3 data that has been lagged by CSAT3_REC_BCK scans.
      GetRecord (dly_data_out(1),delay_3d,CSAT3_REC_BCK)

      Move (Ux,5,dly_data_out(1),5) 'Ux, Uy, Uz, Ts, diag_sonic

      diag_sonic_tmp = IIF (diag_sonic <> NAN,diag_sonic,&hf000)
      diag_sonic_tmp = diag_sonic_tmp >> 12
      diag_sonic_aggregate = diag_sonic_aggregate OR diag_sonic_tmp

      'Extract the four warning flags from the sonic diagnostic word.
      For i = 1 To 4
        diag_bits_sonic(i) = diag_sonic_tmp AND &h1
        diag_sonic_tmp = diag_sonic_tmp >> 1
      Next i

      Ts_absolute = Ts+273.15

      'Filter data in the covariance instruction if the CSAT3 reports bad data.
      sonic_disable_f = (diag_sonic > 63)

      'Load the arrays that hold the input data for the covariance instructions.
      cov_array_sonic(1,1) = Ts
      Move (cov_array_sonic(1,2),3,Ux,3)
      CallTable comp_cov_3d
      If ( comp_cov_3d.Output(1,1) ) Then
        GetRecord (Ts_stdev,comp_cov_3d,1)

        'Rotate the CSAT3 RHC system so the negative x-axis points north.
        wnd_dir_compass = (360+sonic_azimuth-wnd_dir_sonic) MOD 360

        'Make the CSAT3 wind direction fall between 0 to 180 degrees and 0 to -180 degrees.
        If ( wnd_dir_sonic > 180 ) Then ( wnd_dir_sonic = wnd_dir_sonic-360 )

        'Compute online fluxes.
        tau = SQR ((Ux_Uz_cov*Ux_Uz_cov)+(Uy_Uz_cov*Uy_Uz_cov))
        u_star = SQR (tau)

        'Compute the standard deviation from the variance.
        Ts_stdev = SQR (Ts_stdev)
        Ux_stdev = SQR (Ux_stdev)
        Uy_stdev = SQR (Uy_stdev)
        Uz_stdev = SQR (Uz_stdev)
      EndIf
      '*** End of CSAT3 processing ***


      #EndIf
      #If ( (SENSOR_CSAT3 = FALSE) AND (SENSOR_CSAT3B = FALSE) ) Then
      '*** Beginning of CSAT3A sonic head processing ***
      'Load in CSAT3A sonic head data that has been lagged by EC150_REC_BCK scans.
      GetRecord (dly_data_out(1),delay_3d,EC150_REC_BCK)

      Move (Ux,5,dly_data_out(1),5) 'Ux, Uy, Uz, Ts, diag_sonic

      diag_sonic_tmp = IIF ((diag_sonic <> NAN) AND (diag_sonic <> -1),diag_sonic,&h3f)
      diag_sonic_aggregate = diag_sonic_aggregate OR diag_sonic_tmp

      'Extract the six warning flags from the sonic diagnostic word.
      For i = 1 To 6
        diag_bits_sonic(i) = diag_sonic_tmp AND &h1
        diag_sonic_tmp = diag_sonic_tmp >> 1
      Next i

      Ts_absolute = Ts+273.15

      'Filter data in the covariance instruction if the CSAT3A reports bad data.
      sonic_disable_f = (diag_sonic <> 0)

      'Load the arrays that hold the input data for the covariance instructions.
      cov_array_sonic(1,1) = Ts
      Move (cov_array_sonic(1,2),3,Ux,3)
      CallTable comp_cov_3d
      If ( comp_cov_3d.Output(1,1) ) Then
        GetRecord (Ts_stdev,comp_cov_3d,1)

        'Rotate the CSAT3A sonic head RHC system so the negative x-axis points north.
        wnd_dir_compass = (360+sonic_azimuth-wnd_dir_sonic) MOD 360

        'Make the CSAT3A sonic head wind direction fall between 0 to 180 degrees and 0 to -180 degrees.
        If ( wnd_dir_sonic > 180 ) Then ( wnd_dir_sonic = wnd_dir_sonic-360 )

        'Compute online fluxes.
        tau = SQR ((Ux_Uz_cov*Ux_Uz_cov)+(Uy_Uz_cov*Uy_Uz_cov))
        u_star = SQR (tau)

        'Compute the standard deviation from the variance.
        Ts_stdev = SQR (Ts_stdev)
        Ux_stdev = SQR (Ux_stdev)
        Uy_stdev = SQR (Uy_stdev)
        Uz_stdev = SQR (Uz_stdev)
      EndIf
      '*** End of CSAT3A sonic head processing ***


      #EndIf
      #If ( SENSOR_CSAT3B = TRUE ) Then
      '*** Beginning of CSAT3B processing ***
      'Load in CSAT3B data that has been lagged by CSAT3_REC_BCK scans.
      GetRecord (dly_data_out(1),delay_3d,CSAT3_REC_BCK)

      Move (Ux,5,dly_data_out(1),5) 'Ux, Uy, Uz, Ts, diag_sonic

      diag_sonic_tmp = IIF (diag_sonic <> NAN,diag_sonic,&h100)
      diag_sonic_aggregate = diag_sonic_aggregate OR diag_sonic_tmp

      'Extract the nine warning flags from the sonic diagnostic word.
      For i = 1 To 9
        diag_bits_sonic(i) = diag_sonic_tmp AND &h1
        diag_sonic_tmp = diag_sonic_tmp >> 1
      Next i

      Ts_absolute = Ts+273.15

      'Filter data in the covariance instruction if the CSAT3B reports bad data.
      sonic_disable_f = (diag_sonic <> 0)

      'Load the arrays that hold the input data for the covariance instructions.
      cov_array_sonic(1,1) = Ts
      Move (cov_array_sonic(1,2),3,Ux,3)
      CallTable comp_cov_3d
      If ( comp_cov_3d.Output(1,1) ) Then
        GetRecord (Ts_stdev,comp_cov_3d,1)

        'Rotate the CSAT3B RHC system so the negative x-axis points north.
        wnd_dir_compass = (360+sonic_azimuth-wnd_dir_sonic) MOD 360

        'Make the CSAT3B wind direction fall between 0 to 180 degrees and 0 to -180 degrees.
        If ( wnd_dir_sonic > 180 ) Then ( wnd_dir_sonic = wnd_dir_sonic-360 )

        'Compute online fluxes.
        tau = SQR ((Ux_Uz_cov*Ux_Uz_cov)+(Uy_Uz_cov*Uy_Uz_cov))
        u_star = SQR (tau)

        'Compute the standard deviation from the variance.
        Ts_stdev = SQR (Ts_stdev)
        Ux_stdev = SQR (Ux_stdev)
        Uy_stdev = SQR (Uy_stdev)
        Uz_stdev = SQR (Uz_stdev)
      EndIf
      '*** End of CSAT3B processing ***


      #EndIF
      #If ( SENSOR_IRGASON = TRUE ) Then
      '*** Beginning of EC150 processing ***
      'Load in the EC150 data that has been lagged by EC150_REC_BCK scans.
      GetRecord (dly_data_out(1),delay_cs,EC150_REC_BCK)

      Move (CO2,7,dly_data_out(1),7) 'CO2, H2O, diag_irga, amb_tmpr, amb_press, CO2_sig_strgth, H2O_sig_strgth

      'Compute the EC150 dew point temperature from the H2O density at atmospheric pressure and shroud temperature.
      Td_tmp = LOG (H2O*R*(amb_tmpr+273.15)/(11.014*(1.00072+3.2e-5*amb_press+5.9e-9*amb_press*amb_tmpr*amb_tmpr))) 'Td_tmp = ln (H2O*R*(T+273.15)/(Mv*0.61121*f)); Mv = 18.02 g/mol, f = 1.00072+3.2e-5*P+5.9e-9*P*T*T
      Td = (240.97*Td_tmp)/(17.502-Td_tmp) 'Buck (1981) Eq. (2a, 3a, & 6) and Leuning (2004) Eq. (6.23)

      diag_irga_tmp = IIF ((diag_irga <> NAN) AND (diag_irga <> -1),diag_irga,&h4ffefb)
      diag_irga_aggregate = diag_irga_aggregate OR diag_irga_tmp

      'Extract the twenty two flags from the gas analyzer diagnostic word.
      For i = 1 To 22
        diag_bits_irga(i) = diag_irga_tmp AND &h1
        diag_irga_tmp = diag_irga_tmp >> 1
      Next i

      'Compute fast response air temperature from sonic temperature and EC150 vapor density.
      Tc = Ts_absolute/(1+0.32*H2O*R*Ts_absolute/(amb_press*18.02)) 'Kaimal and Gaynor (1991) Eq. (3).

      'Compute the molar mixing ratio of CO2 and H2O.
      divisor = (amb_press/(R*Tc))-(H2O/18.02)
      Xc = CO2/(0.044*divisor)
      Xv = H2O/(0.01802*divisor)

      'Convert the fast response air temperature to degrees C.
      Tc = Tc-273.15

      'Filter data in the covariance instruction if the EC150 w/ CSAT3A sonic head reports bad data.
      irga_disable_f = ( CO2_sig_strgth < CO2_SIG_STRGTH_THRESHOLD ) OR ( H2O_sig_strgth < H2O_SIG_STRGTH_THRESHOLD ) OR (diag_irga <> 0 )

      'Load the arrays that hold the input data for the covariance instructions.
      cov_array_cs(1,1) = CO2
      Move (cov_array_cs(1,2),3,Ux,3)
      cov_array_cs(2,1) = H2O
      Move (cov_array_cs(2,2),3,Ux,3)
      cov_array_cs(3,1) = Tc
      Move (cov_array_cs(3,2),3,Ux,3)
      CallTable comp_cov_cs
      If ( comp_cov_cs.Output(1,1) ) Then
        GetRecord (CO2_stdev,comp_cov_cs,1)

        rho_d_mean = (amb_press_mean/((Tc_mean+273.15)*RD))-(H2O_mean*MU_WPL)
        Cp = 1004.67*(1+0.84*(0.622*H2O_mean*RV*(Tc_mean+273.15)/amb_press_mean)) 'Stull (1989)
        rho_a_mean = (rho_d_mean+H2O_mean)/1000
        Lv = 2501-(2.37*Tc_mean) 'Stull (1989)

        'Compute online fluxes.
        Fc_irga = CO2_Uz_cov
        LE_irga = Lv*H2O_Uz_cov

        'Compute the standard deviation from the variance.
        CO2_stdev = SQR (CO2_stdev)
        H2O_stdev = SQR (H2O_stdev)
        Tc_stdev = SQR (Tc_stdev)

        sigma_wpl = H2O_mean/rho_d_mean

        'EC150 Webb et al. (1980) term for carbon dioxide Eq. (24).
        CO2_wpl_LE = MU_WPL*CO2_mean/rho_d_mean*H2O_Uz_cov
        CO2_wpl_H = (1+(MU_WPL*sigma_wpl))*CO2_mean/(Tc_mean+273.15)*Tc_Uz_cov
        Fc_wpl = Fc_irga+CO2_wpl_LE+CO2_wpl_H

        'EC150 Webb et al. (1980) term for water vapor Eq. (25).
        H2O_wpl_LE = MU_WPL*sigma_wpl*LE_irga
        H2O_wpl_H = (1+(MU_WPL*sigma_wpl))*H2O_mean/(Tc_mean+273.15)*Lv*Tc_Uz_cov
        LE_wpl = LE_irga+H2O_wpl_LE+H2O_wpl_H
      EndIf
      '*** End of EC150 processing ***


      #EndIf
      #If ( ((SENSOR_CSAT3 = TRUE) OR (SENSOR_CSAT3B = TRUE)) AND (SENSOR_TMPR_RH = TRUE) AND (SENSOR_IRGASON = FALSE) AND (SENSOR_LI7500 = FALSE) ) Then
      '*** Beginning of temperature and humidity processing ***
      CallTable stats_tmpr_rh
      If ( stats_tmpr_rh.Output(1,1) ) Then
        GetRecord (T_tmpr_rh_mean,stats_tmpr_rh,1)

        H2O_tmpr_rh_mean = e_tmpr_rh_mean/((T_tmpr_rh_mean+273.15)*RV)
        rho_d_tmpr_rh_mean = (SITE_PRESS-e_tmpr_rh_mean)/((T_tmpr_rh_mean+273.15)*RD)
        rho_a_tmpr_rh_mean = (rho_d_tmpr_rh_mean+H2O_tmpr_rh_mean)/1000
        RH_tmpr_rh_mean = 100*e_tmpr_rh_mean/e_sat_tmpr_rh_mean
      EndIf
      '*** End of temperature and humidity probe processing ***


      #EndIf
      #If ( ((SENSOR_TMPR_RH = TRUE) AND (SENSOR_IRGASON = TRUE) AND (SENSOR_LI7500 = FALSE)) OR ((SENSOR_TMPR_RH = TRUE) AND (SENSOR_IRGASON = TRUE) AND (SENSOR_LI7500 = TRUE)) ) Then
      '*** Beginning of temperature and humidity processing ***
      CallTable stats_tmpr_rh
      If ( stats_tmpr_rh.Output(1,1) ) Then
        GetRecord (T_tmpr_rh_mean,stats_tmpr_rh,1)

        H2O_tmpr_rh_mean = e_tmpr_rh_mean/((T_tmpr_rh_mean+273.15)*RV)
        rho_d_tmpr_rh_mean = (amb_press_mean-e_tmpr_rh_mean)/((T_tmpr_rh_mean+273.15)*RD)
        rho_a_tmpr_rh_mean = (rho_d_tmpr_rh_mean+H2O_tmpr_rh_mean)/1000
        RH_tmpr_rh_mean = 100*e_tmpr_rh_mean/e_sat_tmpr_rh_mean
      EndIf
      '*** End of temperature and humidity probe processing ***


      #EndIf
      #If ( (SENSOR_TMPR_RH = TRUE) AND (SENSOR_IRGASON = FALSE) AND (SENSOR_LI7500 = TRUE) ) Then
      '*** Beginning of temperature and humidity processing ***
      CallTable stats_tmpr_rh
      If ( stats_tmpr_rh.Output(1,1) ) Then
        GetRecord (T_tmpr_rh_mean,stats_tmpr_rh,1)

        H2O_tmpr_rh_mean = e_tmpr_rh_mean/((T_tmpr_rh_mean+273.15)*RV)
        rho_d_tmpr_rh_mean = (amb_press_li_mean-e_tmpr_rh_mean)/((T_tmpr_rh_mean+273.15)*RD)
        rho_a_tmpr_rh_mean = (rho_d_tmpr_rh_mean+H2O_tmpr_rh_mean)/1000
        RH_tmpr_rh_mean = 100*e_tmpr_rh_mean/e_sat_tmpr_rh_mean
      EndIf
      '*** End of temperature and humidity processing ***


      #EndIf
      #If ( SENSOR_KH20 = TRUE ) Then
      '*** Beginning of KH20 processing ***
      'Load in the KH20 data that has been lagged by OFFSET scans.
      GetRecord (dly_data_out(1),delay_kh,OFFSET)

      Move (kh,2,dly_data_out(1),2) 'kh, ln_kh

      'Load the arrays that hold the input data for the covariance instructions.
      cov_array_kh(1) = ln_kh
      Move (cov_array_kh(2),3,Ux,3)
      cov_array_kh(5) = Ts
      CallTable comp_cov_kh
      If ( comp_cov_kh.Output(1,1) ) Then
        GetRecord (H2O_kh_stdev,comp_cov_kh,1)

        H2O_tmpr_rh_mean = e_tmpr_rh_mean/((T_tmpr_rh_mean+273.15)*RV)
        #If ( (SENSOR_IRGASON = FALSE) AND (SENSOR_LI7500 = FALSE) ) Then
        rho_d_tmpr_rh_mean = (SITE_PRESS-e_tmpr_rh_mean)/((T_tmpr_rh_mean+273.15)*RD)
        Cp = 1004.67*(1+0.84*(0.622*e_tmpr_rh_mean/SITE_PRESS)) 'Stull (1989)
        #EndIf
        #If ( ((SENSOR_IRGASON = TRUE) AND (SENSOR_LI7500 = FALSE)) OR ((SENSOR_IRGASON = TRUE) AND (SENSOR_LI7500 = TRUE)) ) Then
        rho_d_tmpr_rh_mean = (amb_press_mean-e_tmpr_rh_mean)/((T_tmpr_rh_mean+273.15)*RD)
        Cp = 1004.67*(1+0.84*(0.622*e_tmpr_rh_mean/amb_press_mean)) 'Stull (1989)
        #EndIf
        #If ( (SENSOR_IRGASON = FALSE) AND (SENSOR_LI7500 = TRUE) ) Then
        rho_d_tmpr_rh_mean = (amb_press_li_mean-e_tmpr_rh_mean)/((T_tmpr_rh_mean+273.15)*RD)
        Cp = 1004.67*(1+0.84*(0.622*e_tmpr_rh_mean/amb_press_li_mean)) 'Stull (1989)
        #EndIf
        rho_a_tmpr_rh_mean = (rho_d_tmpr_rh_mean+H2O_tmpr_rh_mean)/1000
        RH_tmpr_rh_mean = 100*e_tmpr_rh_mean/e_sat_tmpr_rh_mean
        Lv = 2501-(2.37*T_tmpr_rh_mean) 'Stull (1989)

        'Scale the KH20 cross products.
        H2O_kh_Ux_cov = H2O_kh_Ux_cov/XKW
        H2O_kh_Uy_cov = H2O_kh_Uy_cov/XKW
        H2O_kh_Uz_cov = H2O_kh_Uz_cov/XKW
        H2O_kh_Ts_cov = H2O_kh_Ts_cov/XKW
        H2O_kh_stdev = H2O_kh_stdev/(XKW*XKW)

        'Compute online fluxes.
        LE_kh = Lv*H2O_kh_Uz_cov

        #If ( (SENSOR_IRGASON = FALSE) AND (SENSOR_LI7500 = FALSE) ) Then
        'Compute the KH20 oxygen correction for latent heat flux and water
        ' vapor density variance.
        oc_LE = Lv*KO*CO*MO*SITE_PRESS/(KW*R*(T_tmpr_rh_mean+273.15)*(T_tmpr_rh_mean+273.15))*Ts_Uz_cov
        oc_var = -2*KO*CO*MO*SITE_PRESS/(X*KW*KW*R*(T_tmpr_rh_mean+273.15)*(T_tmpr_rh_mean+273.15))*H2O_kh_Ts_cov
        #EndIf
        #If ( ((SENSOR_IRGASON = TRUE) AND (SENSOR_LI7500 = FALSE)) OR ((SENSOR_IRGASON = TRUE) AND (SENSOR_LI7500 = TRUE)) ) Then
        'Compute the KH20 oxygen correction for latent heat flux and water
        ' vapor density variance.
        oc_LE = Lv*KO*CO*MO*amb_press_mean/(KW*R*(T_tmpr_rh_mean+273.15)*(T_tmpr_rh_mean+273.15))*Ts_Uz_cov
        oc_var = -2*KO*CO*MO*amb_press_mean/(X*KW*KW*R*(T_tmpr_rh_mean+273.15)*(T_tmpr_rh_mean+273.15))*H2O_kh_Ts_cov
        #EndIf
        #If ( (SENSOR_IRGASON = FALSE) AND (SENSOR_LI7500 = TRUE) ) Then
        'Compute the KH20 oxygen correction for latent heat flux and water
        ' vapor density variance.
        oc_LE = Lv*KO*CO*MO*amb_press_li_mean/(KW*R*(T_tmpr_rh_mean+273.15)*(T_tmpr_rh_mean+273.15))*Ts_Uz_cov
        oc_var = -2*KO*CO*MO*amb_press_li_mean/(X*KW*KW*R*(T_tmpr_rh_mean+273.15)*(T_tmpr_rh_mean+273.15))*H2O_kh_Ts_cov
        #EndIf

        'Compute the standard deviation from the variance.
        H2O_kh_stdev = SQR (H2O_kh_stdev+oc_var)

        sigma_wpl_kh = H2O_tmpr_rh_mean/rho_d_tmpr_rh_mean

        'KH20 Webb et al. term for water vapor Eq. (25).
        H2O_kh_wpl_LE_kh = MU_WPL*sigma_wpl_kh*(LE_kh-oc_LE)
        H2O_kh_wpl_H_kh = (1+(MU_WPL*sigma_wpl_kh))*H2O_tmpr_rh_mean/(T_tmpr_rh_mean+273.15)*Lv*Ts_Uz_cov

        LE_kh_wpl = LE_kh-oc_LE+H2O_kh_wpl_LE_kh+H2O_kh_wpl_H_kh
      EndIf
      '*** End of KH20 processing ***


      #EndIf
      #If ( SENSOR_FW = TRUE ) Then
      '*** Beginning of FW05 processing ***
      'Load in the FW05 data that has been lagged by OFFSET scans.
      GetRecord (dly_data_out(1),delay_fw,OFFSET)

      Move (fw,1,dly_data_out(1),1) 'fw

      'Load the arrays that hold the input data for the covariance instructions.
      cov_array_fw(1) = fw
      Move (cov_array_fw(2),3,Ux,3)
      CallTable comp_cov_fw
      If ( comp_cov_fw.Output(1,1) ) Then
        GetRecord (fw_stdev,comp_cov_fw,1)

        'Compute the standard deviation from the variance.
        fw_stdev = SQR (fw_stdev)
      EndIf
      '*** End of FW05 processing ***


      #EndIf
      #If ( SENSOR_LI7500 = TRUE ) Then
      '*** Beginning of LI-7500(A) processing ***
      'Load in the LI-7500(A) data that has been lagged by LI7500_REC_BCK scans.
      GetRecord (dly_data_out(1),delay_li,LI7500_REC_BCK)

      Move (CO2_li,5,dly_data_out(1),5) 'CO2, H2O, press, agc, diag

      diag_irga_li_tmp = IIF (diag_irga_li <> NAN,diag_irga_li,&h00)
      diag_irga_li_tmp = diag_irga_li_tmp XOR &hf0
      diag_irga_li_tmp = diag_irga_li_tmp >> 4
      diag_irga_li_aggregate = diag_irga_li_aggregate OR diag_irga_li_tmp

      'Extract the four flags from the gas analyzer diagnostic word.
      For i = 1 To 4
        diag_bits_irga_li(i) = diag_irga_li_tmp AND &h1
        diag_irga_li_tmp = diag_irga_li_tmp >> 1
      Next i

      'Compute fast response air temperature from sonic temperature and IRGA
      ' vapor density (see sonic manual).
      Tc_li = Ts_absolute/(1+0.32*H2O_li*R*Ts_absolute/(amb_press_li*18.02)) 'Kaimal and Gaynor (1991) Eq. 3

      'Compute the molar mixing ratio of CO2 and H2O.
      divisor_li = (amb_press_li/(R*Tc_li))-(H2O_li/18.02)
      Xc_li = CO2_li/(0.044*divisor_li)
      Xv_li = H2O_li/(0.01802*divisor_li)

      'Convert the fast response air temperature to degrees C.
      Tc_li = Tc_li-273.15

      'Filter data in the covariance instruction if the LI-7500(A) reports bad data.
      irga_li_disable_f = (agc_li > AGC_THRESHOLD) OR (H2O_li = NAN)

      'Load the arrays that hold the input data for the covariance instructions.
      cov_array_li(1,1) = CO2_li
      Move (cov_array_li(1,2),3,Ux,3)
      cov_array_li(2,1) = H2O_li
      Move (cov_array_li(2,2),3,Ux,3)
      cov_array_li(3,1) = Tc_li
      Move (cov_array_li(3,2),3,Ux,3)
      CallTable comp_cov_li

      If ( comp_cov_li.Output(1,1) ) Then
        GetRecord (CO2_li_stdev,comp_cov_li,1)

        rho_d_li_mean = (amb_press_li_mean/((Tc_li_mean+273.15)*RD))-(H2O_li_mean*MU_WPL)
        Cp = 1004.67*(1+0.84*(0.622*H2O_li_mean*RV*(Tc_li_mean+273.15)/amb_press_li_mean)) 'Stull (1989)
        rho_a_li_mean = (rho_d_li_mean+H2O_li_mean)/1000
        Lv = 2501-(2.37*Tc_li_mean) 'Stull (1989)

        'Compute online fluxes.
        Fc_li_irga = CO2_li_Uz_cov
        LE_li_irga = Lv*H2O_li_Uz_cov

        'Compute the standard deviation from the variance.
        CO2_li_stdev = SQR (CO2_li_stdev)
        H2O_li_stdev = SQR (H2O_li_stdev)
        Tc_li_stdev = SQR (Tc_li_stdev)

        sigma_wpl_li = H2O_li_mean/rho_d_li_mean

        'LI-7500(A) Webb et al. term for carbon dioxide Eq. (24).
        CO2_li_wpl_LE_li = MU_WPL*CO2_li_mean/rho_d_li_mean*H2O_li_Uz_cov
        CO2_li_wpl_H_li = (1+(MU_WPL*sigma_wpl_li))*CO2_li_mean/(Tc_li_mean+273.15)*Tc_li_Uz_cov
        Fc_li_wpl = Fc_li_irga+CO2_li_wpl_LE_li+CO2_li_wpl_H_li

        'LI-7500(A) Webb et al. term for water vapor Eq. (25).
        H2O_li_wpl_LE_li = MU_WPL*sigma_wpl_li*LE_li_irga
        H2O_li_wpl_H_li = (1+(MU_WPL*sigma_wpl_li))*H2O_li_mean/(Tc_li_mean+273.15)*Lv*Tc_li_Uz_cov
        LE_li_wpl = LE_li_irga+H2O_li_wpl_LE_li+H2O_li_wpl_H_li
      EndIf
      '*** End of LI-7500(A) processing ***


      #EndIf
      '*** Beginning of sonic sensible heat, momentum, and sensible heat flux processing ***
      If ( comp_cov_3d.Output(1,1) ) Then
        #If ( (SENSOR_TMPR_RH = FALSE) AND (SENSOR_IRGASON = FALSE ) AND (SENSOR_LI7500 = FALSE) ) Then
        'CSAT3 sensible heat flux using sonic temperature.
        Hs = SITE_RHO_A*SITE_CP*Ts_Uz_cov          'Air density and specific heat are site attendant estimates.

        'CSAT3 momentum flux.
        tau = SITE_RHO_A*tau                       'Air density is a site attendant estimate.
        #If ( SENSOR_FW = TRUE ) Then

        'Sensible heat flux using finewire thermocouple temperature.
        H = SITE_RHO_A*SITE_CP*fw_Uz_cov           'Air density and specific heat are site attendant estimates.
        #EndIf
        #EndIf
        #If ( (SENSOR_TMPR_RH = TRUE) AND (SENSOR_IRGASON = FALSE ) AND (SENSOR_LI7500 = FALSE) ) Then
        'CSAT3 sensible heat flux using sonic temperature.
        Hs = rho_a_tmpr_rh_mean*Cp*Ts_Uz_cov       'Air density is a site attendant estimate.

        'CSAT3 momentum flux.
        tau = rho_a_tmpr_rh_mean*tau               'Air density is a site attendant estimate.
        #If ( SENSOR_FW = TRUE ) Then

        'Sensible heat flux using finewire thermocouple temperature.
        H = rho_a_tmpr_rh_mean*fw_Uz_cov           'Air density is a site attendant estimate.
        #EndIf
        #EndIf
        #If ( ((SENSOR_TMPR_RH = TRUE) AND (SENSOR_IRGASON = TRUE)) OR ((SENSOR_TMPR_RH = TRUE) AND (SENSOR_LI7500 = TRUE)) ) Then
        'CSAT3(A) sensible heat flux using sonic temperature.
        Hs = rho_a_tmpr_rh_mean*Cp*Ts_Uz_cov       'Air density computed from temperature and humidity probe.

        'CSAT3(A) momentum flux.
        tau = rho_a_tmpr_rh_mean*tau               'Air density computed from temperature and humidity probe.
        #If ( SENSOR_LI7500 = TRUE ) Then

        'Sensible heat flux using sonic temperature corrected for water vapor measured by the LI-7500(A).
        Hc_li = rho_a_tmpr_rh_mean*Cp*Tc_li_Uz_cov 'Air density computed from temperature and humidity probe.
        #EndIf
        #If ( SENSOR_IRGASON = TRUE ) Then

        'Sensible heat flux using sonic temperature corrected for water vapor measured by the EC150.
        Hc = rho_a_tmpr_rh_mean*Cp*Tc_Uz_cov       'Air density computed from temperature and humidity probe.
        #EndIf
        #If ( SENSOR_FW = TRUE ) Then

        'Sensible heat flux using finewire thermocouple temperature.
        H = rho_a_tmpr_rh_mean*Cp*fw_Uz_cov        'Air density computed from temperature and humidity probe.
        #EndIf
        #EndIf
        #If ( (SENSOR_TMPR_RH = FALSE) AND (SENSOR_IRGASON = FALSE) AND (SENSOR_LI7500 = TRUE) ) Then
        'CSAT3(A) sensible heat flux using sonic temperature.
        Hs = rho_a_li_mean*Cp*Ts_Uz_cov            'Air density computed from LI-7500(A).

        'CSAT3(A) momentum flux.
        tau = rho_a_li_mean*tau                    'Air density computed from LI-7500(A).

        'Sensible heat flux using sonic temperature corrected for water vapor measured by the LI-7500(A).
        Hc_li = rho_a_li_mean*Cp*Tc_li_Uz_cov      'Air density computed from LI-7500(A).
        #If ( SENSOR_FW = TRUE ) Then

        'Sensible heat flux using finewire thermocouple temperature.
        H = rho_a_li_mean*Cp*fw_Uz_cov             'Air density computed from LI-7500(A).
        #EndIf
        #EndIf
        #If ( (SENSOR_TMPR_RH = FALSE) AND (SENSOR_IRGASON = TRUE) ) Then
        'CSAT3(A) sensible heat flux using sonic temperature.
        Hs = rho_a_mean*Cp*Ts_Uz_cov               'Air density computed from EC150.

        'CSAT3(A) momentum flux.
        tau = rho_a_mean*tau                       'Air density computed from EC150.

        'Sensible heat flux using sonic temperature corrected for water vapor measured by the EC150.
        Hc = rho_a_mean*Cp*Tc_Uz_cov               'Air density computed from EC150.
        #If ( SENSOR_FW = TRUE ) Then

        'Sensible heat flux using finewire thermocouple temperature.
        H = rho_a_mean*Cp*fw_Uz_cov                'Air density computed from EC150.
        #EndIf
        #EndIf
      EndIf
      '*** End of sensible heat flux processing ***
      #If ( SENSOR_TCAV = TRUE ) Then


      '*** Beginning of soil temperature processing ***
      CallTable stats_soil
      If ( stats_soil.Output(1,1) ) Then
        GetRecord (Tsoil_mean(1),stats_soil,1)

        'Compute the change in soil temperature.
        For i = 1 To NMBR_TCAV
          del_Tsoil(i) = Tsoil_mean(i)-prev_Tsoil(i)
          prev_Tsoil(i) = Tsoil_mean(i)
        Next i
      EndIf
      '*** End of soil temperature processing ***
      #EndIf


      CallTable flux
      If ( flux.Output(1,1) ) Then
        diag_sonic_aggregate = 0
        #If (SENSOR_IRGASON = TRUE ) Then
        diag_irga_aggregate = 0
        #EndIf
        #If (SENSOR_LI7500 = TRUE ) Then
        diag_irga_li_aggregate = 0
        #EndIf
      EndIf

      slowsequence_disable_f = TRUE
      If ( slowsequence_finished_f ) Then
        slowsequence_finished_f = FALSE
        slowsequence_disable_f = FALSE
      EndIf
    Else
      scan_count += 1
    EndIf

    CallTable diagnostic
    process_time = Status.ProcessTime(1,1)
    buff_depth = Status.BuffDepth(1,1)
 
    #If ( SENSOR_IRGASON = TRUE ) Then

    '*** Beginning of EC150 w/ CSAT3A sonic head measurements ***
    EC100 (sonic_irga_raw(1),EC100_SDM_ADDR,1)
    '*** End of EC150 w/ CSAT3A sonic head measurements ***
    #EndIf
    #If ( SENSOR_CSAT3 = TRUE ) Then

    '*** Beginning of CSAT3 measurements ***
    CSAT3 (sonic_irga_raw(1),1,CSAT3_SDM_ADDR,91,CSAT_OPT)
    '*** End of CSAT3 measurements ***
    #EndIf
    #If ( SENSOR_CSAT3B = TRUE ) Then

    '*** Beginning of CSAT3B measurements ***
    CSAT3B (sonic_irga_raw(1),0,CSAT3B_SDM_ADDR,0)
    '*** End of CSAT3B measurements ***
    #EndIf
    #If ( SENSOR_LI7500 = TRUE ) Then

    '*** Beginning of LI-7500(A) measurements ***
    CS7500 (irga_li_raw(1),1,LI7500_SDM_ADDR,6)
    '*** End of LI-7500(A) measurements ***
    #EndIf
  NextScan


SlowSequence

  Scan (5,Sec,3,0)
    #If ( SENSOR_IRGASON = TRUE ) Then
    sec_since_last_cmd = Timer (1,Sec,4)
    #EndIf

    'Measure battery voltage.
    Battery (batt_volt)
    #If ( SENSOR_TMPR_RH = TRUE ) Then


    '*** Beginning of temperature and humidity probe measurements ***
    VoltSe (T_tmpr_rh,2,AutoRange,TMPR_RH_ANALOG_INPUT,FALSE,0,ANALOG_INTEGRATION,1,0)
    T_tmpr_rh = T_tmpr_rh*TMPR_RH_T_MULT+TMPR_RH_T_OFFSET
    RH_tmpr_rh = RH_tmpr_rh*0.1
    VaporPressure (e_tmpr_rh,T_tmpr_rh,RH_tmpr_rh)
    SatVP (e_sat_tmpr_rh,T_tmpr_rh)
    '*** End of temperature and humidity probe measurements ***
    #EndIf
    #If ( SENSOR_Q7_1 = TRUE ) Then


    '*** Beginning of Q7.1 measurements ***
    VoltDiff (Rn_meas,1,AutoRange,NR_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)

    'Apply calibration and wind correction to net radiometer measurement.
    If ( hor_wind_diag = 0 ) Then
      If (Rn_meas > 0) Then
        Rn_meas = Rn_meas*Q7_1_POS_CAL
        Rn = Rn_meas*(1+(0.0132*hor_wind)/(0.066+(0.2*hor_wind)))
      Else
        Rn_meas = Rn_meas*Q7_1_NEG_CAL
        Rn = Rn_meas*((0.00174*hor_wind)+0.99755)
      EndIf
    Else
      If (Rn_meas > 0) Then
        Rn_meas = Rn_meas*Q7_1_POS_CAL
        Rn = Rn_meas*1.045
      Else
        Rn_meas = Rn_meas*Q7_1_NEG_CAL
        Rn = Rn_meas
      EndIf
    EndIf
    '*** End of Q7.1 measurements ***
    #EndIf
    #If ( SENSOR_NR_LITE_2 = TRUE ) Then


    '*** Beginning of NR Lite 2 measurements ***
    VoltDiff (Rn_meas,1,AutoRange,NR_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,NRLITE_CAL,0)

    'Apply calibration and wind correction to net radiometer measurement.
    If ( (hor_wind_diag = 0) AND (hor_wind > 5) ) Then
      Rn = Rn_meas*(1+(0.021286*(hor_wind-5)))
    Else
      Rn = Rn_meas
    EndIf
    '*** End of NR Lite 2 measurements ***
    #EndIf
    #If ( SENSOR_CNR_2 = TRUE ) Then


    '*** Beginning of CNR 2 measurements ***
    VoltDiff (Rn_sw,2,AutoRange,NR_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)
    Rn_sw = Rn_sw*NR_SW_CAL
    Rn_lw = Rn_lw*NR_LW_CAL
    Rn = Rn_sw+Rn_lw
    '*** End of CNR 2 measurements ***
    #EndIf
    #If ( SENSOR_NR_01_CNR_1 = TRUE ) Then


    '*** Beginning of NR 01/CNR 1 measurements ***
    VoltDiff (Rs_incoming,4,AutoRange,NR_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)
    Rs_incoming = Rs_incoming*NR_SW_INCOMING_CAL
    Rs_outgoing = Rs_outgoing*NR_SW_OUTGOING_CAL
    Rl_incoming = Rl_incoming*NR_LW_INCOMING_CAL
    Rl_outgoing = Rl_outgoing*NR_LW_OUTGOING_CAL

    Resistance (T_nr,1,mV200,T_NR_ANALOG_INPUT,T_NR_CURRENT_EXCITATION,1,1675,TRUE,TRUE,0,ANALOG_INTEGRATION,1,0)
    T_nr = T_nr/100
    PRT (T_nr,1,T_nr,1,273.15)

    'Compute net radiation, albedo, incoming and outgoing longwave radiation.
    Rn = Rs_incoming-Rs_outgoing+Rl_incoming-Rl_outgoing
    albedo = Rs_outgoing/Rs_incoming
    Rl_incoming_meas = Rl_incoming
    Rl_outgoing_meas = Rl_outgoing
    Rl_incoming = Rl_incoming+(5.67e-8*T_nr*T_nr*T_nr*T_nr)
    Rl_outgoing = Rl_outgoing+(5.67e-8*T_nr*T_nr*T_nr*T_nr)
    '*** End of NR 01/CNR 1 measurements ***
    #EndIf
    #If ( SENSOR_CNR_4 = TRUE ) Then


    '*** Beginning of CNR 4 measurements ***
    VoltDiff (Rs_incoming,4,AutoRange,NR_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)
    Rs_incoming = Rs_incoming*NR_SW_INCOMING_CAL
    Rs_outgoing = Rs_outgoing*NR_SW_OUTGOING_CAL
    Rl_incoming = Rl_incoming*NR_LW_INCOMING_CAL
    Rl_outgoing = Rl_outgoing*NR_LW_OUTGOING_CAL

    BrHalf (X_cnr4,1,AutoRange,T_NR_ANALOG_INPUT,T_NR_VOLTAGE_EXCITATION,1,5000,TRUE,0,ANALOG_INTEGRATION,1,0)
    ln_R = LOG (1000*X_cnr4/(1-X_cnr4))
    T_nr = (1/(A_SHH+B_SHH*ln_R+C_SHH*ln_R*ln_R*ln_R))

    'Compute net radiation, albedo, incoming and outgoing longwave radiation.
    Rn = Rs_incoming-Rs_outgoing+Rl_incoming-Rl_outgoing
    albedo = Rs_outgoing/Rs_incoming
    Rl_incoming_meas = Rl_incoming
    Rl_outgoing_meas = Rl_outgoing
    Rl_incoming = Rl_incoming+(5.67e-8*T_nr*T_nr*T_nr*T_nr)
    Rl_outgoing = Rl_outgoing+(5.67e-8*T_nr*T_nr*T_nr*T_nr)
    '*** End of CNR 4 measurements ***
    #EndIf
    #If ( SENSOR_LI200X = TRUE ) Then


    '*** Beginning of LI-200X measurement ***
    VoltDiff (Rs_incoming,1,AutoRange,LI_200X_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,LI_200X_CAL,0)
    If ( Rs_incoming < 0 ) Then ( Rs_incoming = 0 )
    '*** End of LI-200X measurement ***
    #EndIf
    #If ( SENSOR_CS300 = TRUE ) Then


    '*** Beginning of CS300 measurement ***
    VoltDiff (Rs_incoming,1,AutoRange,CS300_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,CS300_CAL,0)
    If ( Rs_incoming < 0 ) Then ( Rs_incoming = 0 )
    '*** End of CS300 measurement ***
    #EndIf
    #If ( SENSOR_LI190SB = TRUE ) Then


    '*** Beginning of LI-190SB measurement ***
    VoltDiff (par,1,AutoRange,LI_190SB_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,LI_190SB_CAL,0)
    '*** End of LI-190SB measurement ***
    #EndIf
    #If ( SENSOR_TCAV = TRUE ) Then


    '*** Beginning of TCAV measurements ***
    TCDiff (Tsoil(1),NMBR_TCAV,AutoRange,TCAV_ANALOG_INPUT,TypeE,panel_tmpr,TRUE,0,ANALOG_INTEGRATION,1,0)
    '*** End of TCAV measurements ***
    #EndIf
    #If ( SENSOR_CS616 = TRUE ) Then


    '*** Beginning of CS616 measurements ***
    CS616 (cs616_wcr(1),NMBR_CS616,CS616_ANALOG_INPUT,CS616_POWER_CTRL,NMBR_CS616,1,0)
    'Apply temperature correction to CS616 period and find volumetric water content.
    For ii = 1 To NMBR_TCAV 'NMBR_TCAV must equal NMBR_CS616
      If ( (10 <= Tsoil(ii)) AND (Tsoil(ii) <= 40) ) Then
        cs616_T(ii) = cs616_wcr(ii)+(20-Tsoil(ii))*(0.526+cs616_wcr(ii)*(-0.052+cs616_wcr(ii)*0.00136))
      Else
        cs616_T(ii) = cs616_wcr(ii)
      EndIf
      soil_water(ii) = A0_CS616+cs616_wcr(ii)*(A1_CS616+cs616_wcr(ii)*A2_CS616)
      soil_water_T(ii) = A0_CS616+cs616_T(ii)*(A1_CS616+cs616_T(ii)*A2_CS616)
    Next ii
    '*** End of CS616 measurements ***
    #EndIf
    #If ( SENSOR_CS65X = TRUE ) Then


    '*** Beginning of CS65X measurements ***
    SDI12Recorder (cs65x_raw(1),CS65X_1_SDI12_PORT,0,"M!",1,0)
    cs65x_wcr(1) = cs65x_raw(1)
    cs65x_ec(1) = cs65x_raw(2)
    cs65x_tmpr(1) = cs65x_raw(3)

    SDI12Recorder (cs65x_raw(1),CS65X_2_SDI12_PORT,0,"M!",1,0)
    cs65x_wcr(2) = cs65x_raw(1)
    cs65x_ec(2) = cs65x_raw(2)
    cs65x_tmpr(2) = cs65x_raw(3)

    'Duplicate above for additional probes.
    '*** End of CS65X measurements ***
    #EndIf
    #If ( SENSOR_HFT3 = TRUE ) Then


    '*** Beginning of HFT3 measurements ***
    VoltDiff (shf(1),NMBR_SHF,AutoRange,SHF_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,shf_cal(),0)
    '*** End of HFT3 measurements ***
    #EndIf
    #If ( SENSOR_HFP01 = TRUE ) Then


    '*** Beginning of HFP01 measurements ***
    VoltDiff (shf(1),NMBR_SHF,AutoRange,SHF_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,shf_cal(),0)
    '*** End of HFP01 measurements ***
    #EndIf
    #If ( SENSOR_HFP01SC = TRUE ) Then


    '*** Beginning of HFP01SC measurements ***
    'Power the HFP01SC heaters.
    PortSet (9,sw12_1_state)

    VoltSe (shf_mV_raw(1,1),SHF_REPS,AutoRange,SHF_ANALOG_INPUT,FALSE,0,ANALOG_INTEGRATION,1,0)

    'Apply HFP01SC soil heat flux plate calibration and heater scaling.
    For ii = 1 To NMBR_SHF
      shf_mV(ii) = shf_mV_raw(ii,1)
      shf(ii) = shf_mV(ii)*shf_cal(ii)
      V_Rf(ii) = shf_mV_raw(ii,2)*0.001
    Next ii


    'Begin HFP01SC calibration one minute into very CAL_INTERVAL minutes.
    If ( IfTime (1,CAL_INTERVAL,Min) ) Then
      shf_cal_on_f = TRUE
      Move (shf_mV_0(1),NMBR_SHF,shf_mV(1),NMBR_SHF)
      sw12_1_state = TRUE
    EndIf

    If ( IfTime (4,CAL_INTERVAL,Min) ) Then
      Move (shf_mV_180(1),NMBR_SHF,shf_mV(1),NMBR_SHF)
      Move (V_Rf_180(1),NMBR_SHF,V_Rf(1),NMBR_SHF)
      sw12_1_state = FALSE
    EndIf

    'End HFP01SC calibration sequence.
    If ( IfTime (END_CAL,CAL_INTERVAL,Min) ) Then
      Move (shf_mV_end(1),NMBR_SHF,shf_mV(1),NMBR_SHF)
      'Compute new HFP01SC calibration factors.
      For ii = 1 To NMBR_SHF
        shf_cal(ii) = V_Rf_180(ii)*V_Rf_180(ii)*128.7/ABS (((shf_mV_0(ii)+shf_mV_end(ii))/2)-shf_mV_180(ii))
      Next ii
      shf_cal_on_f = FALSE
    EndIf
    '*** End of HFP01SC measurements ***
    #EndIf
    #If ( SENSOR_SI_111 = TRUE ) Then


    '*** Beginning of SI-111 measurements ***
    BrHalf (X_si_111,1,Autorange,IR_BODY_ANALOG_INPUT,IR_VOLTAGE_EXCITATION,1,2500,TRUE,0,ANALOG_INTEGRATION,1,0)
    ln_Rs_si_111 = LOG (24900*(1-X_si_111)/X_si_111)
    si_body_tmpr = 1/(A_SHH_SI_111+ln_Rs_si_111*(B_SHH_SI_111+C_SHH_SI_111*ln_Rs_si_111*ln_Rs_si_111))-273.15
    VoltDiff (ir_tmpr,1,mV20C,IR_TARGET_ANALOG_INPUT,TRUE,0,ANALOG_INTEGRATION,1,0)

    m = MC0+si_body_tmpr*(MC1+si_body_tmpr*MC2)
    b = BC0+si_body_tmpr*(BC1+si_body_tmpr*BC2)
    si_body_tmpr = si_body_tmpr+273.15
    ir_tmpr = ((si_body_tmpr*si_body_tmpr*si_body_tmpr*si_body_tmpr)+m*ir_tmpr+b)^0.25-273.15
    '*** End of SI-111 measurements ***
    #EndIf


    'Update CPU configuration file if sonic azimuth has changed.
    If ( sonic_azimuth_prev <> sonic_azimuth ) Then
      Erase (curr_value_str)
      Erase (prev_value_str)
      Erase (err_message_str)
      curr_value_str = sonic_azimuth
      prev_value_str = sonic_azimuth_prev
      err_message_str = "Sonic Azimuth was changed and saved."
      CallTable sys_log

      sonic_azimuth_prev = sonic_azimuth
      sys_conf_var(1) = sonic_azimuth
      Calfile (sys_conf_var(1),2,"CPU:sys_conf_var.dat",0)
    EndIf
    #If ( SENSOR_IRGASON = TRUE ) Then


    'Update system variable file if manual IRGA power control status has changed.
    If ( irga_off_flg_prev <> irga_off_flg ) Then
      Erase (curr_value_str)
      Erase (prev_value_str)
      Erase (err_message_str)
      If ( irga_off_flg ) Then
        curr_value_str = "IRGA off"
        prev_value_str = "IRGA on"
      Else
        curr_value_str = "IRGA on"
        prev_value_str = "IRGA off"
      EndIf
      err_message_str = "IRGA was manually turned on/off."
      CallTable sys_log

      irga_off_flg_prev = irga_off_flg
      sys_conf_var(2) = irga_off_flg
      Calfile (sys_conf_var(1),2,"CPU:sys_conf_var.dat",0)

      If ( irga_off_flg ) Then
        sec_since_last_cmd = Timer (1,Sec,2)
        irga_power_f = TRUE
        power_array(1,2) = 1 'Turn off IRGA.
      Else
        sec_since_last_cmd = Timer (1,Sec,2)
        irga_power_f = TRUE
        power_array(1,2) = 0 'Turn on IRGA.
      EndIf
    EndIf


    '*** Beginning of system power control ***
    If ( (batt_volt < SYSTEM_PWR_OFF_SET_PT) AND (power_array(1,2)=0) AND (irga_off_bit = FALSE) AND (irga_startup_bit = FALSE) ) Then
      sec_since_last_cmd = Timer (1,Sec,2)
      irga_power_f = TRUE
      power_array(1,2) = 1 'Turn off IRGA.

      Erase (curr_value_str)
      Erase (prev_value_str)
      Erase (err_message_str)
      curr_value_str = batt_volt
      err_message_str = "IRGA turned off; low system battery voltage."
      CallTable sys_log
    ElseIf ( (batt_volt > SYSTEM_PWR_OFF_SET_PT+SYSTEM_PWR_DEAD_BAND_WIDTH) AND (sec_since_last_cmd > 10) AND (irga_off_bit = TRUE) AND (irga_off_flg = FALSE) ) Then
      sec_since_last_cmd = Timer (1,Sec,2)
      irga_power_f = TRUE
      power_array(1,2) = 0 'Turn on IRGA.

      Erase (curr_value_str)
      Erase (prev_value_str)
      Erase (err_message_str)
      curr_value_str = batt_volt
      err_message_str = "IRGA turned on; nominal system battery voltage."
      CallTable sys_log
    EndIf
    '*** End of system power control ***
    #EndIf


    slowsequence_finished_f = TRUE
  NextScan
EndProg
